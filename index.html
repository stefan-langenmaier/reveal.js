<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="description" content="JVM/GC introduction and configuration for Solr">
		<meta name="author" content="Stefan Langenmaier">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>JVM/GC introduction and configuration for Solr</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">
		<link rel="stylesheet" href="css/custom.css">
		
		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>JVM/GC Überischt und Konfiguration für Solr</h2>
					
					<aside class="notes">
						<p>
							Hallo, im folgenden möchte ich eine Übersicht über die GCs geben die in der JVM verwendet werden, das ist wichtig weil
							GC ist ein entscheidender Faktor für die Leistung und Stabilität eines Systems
							Das Verhalten des GC mit besonderem Bezug auf Solr
						</p>
					</aside>
				</section>
				
				<section>
					<section>
						<h2>Geschichte der JVM</h2>
						
						<ul>
							<li>abstract computing machine</li>
							<li>specification, implementation, and instance</li>
							<li>entwickelt für Java, aber andere Sprachen möglich</li>
						</ul>
						
						<aside class="notes">
							<p>
								Java virtual machine (JVM) is an abstract computing machine
								three notions of the JVM: specification, implementation, and instance
								
								wurde 1994 von sun eingeführt, zunächst als spezifikation damit die implementierung unabhängig von bestimmten bedingungen ist
								
								alles relativ offen weil als anwendungsgebiet der browser gesehen wurde und es klar war das niemand aleine alle platformen implementieren wird
								
								designed for java the J, aber da abstrakt mit robusten implementierungen und gutes modell um schnell neue sprachen zu entwicken wurde sie auch dafür populär
							</p>
						</aside>
					</section>
					
					<section>
						<h2>Existierende Sprachen</h2>
						
						<p>A JVM language is any language with functionality that can be expressed in terms of a valid class file. <a href="https://en.wikipedia.org/wiki/List_of_JVM_languages">[Wikipedia]</a></p>
						
						<ul>
							<li>Scala, a statically-typed object-oriented and functional programming language</li>
							<li>JRuby, an implementation of Ruby</li>
							<li>Jython, an implementation of Python</li>
							<li>Nashorn, an implementation of Javascript</li>
							<li>...</li>
						</ul>
						
						<aside class="notes">
							<p>
								viele andere, gute basis um neue sprachen zu entwickeln und alte sprachen auf neuere hardware zu portieren
							</p>
						</aside>
					</section>
				</section>
				
				<section>
					<h2>JVM Spezifikation</h2>
					
					<ul>
						<li>32-bit</li>
						<li>hybrid mit einem Stack and register–register oder load/store Ansatz</li>
						<li>Datentypen</li>
						<li>class loader</li>
					</ul>
					
					<aside class="notes">
						<p>
							die vm hat laut spezifikation 32-bit, heute sind ja viele desktop rechner 64-bit

							also das interne speichermodell weiterhin 32-bit, daher z.b. das problem mit 32gb jvm instancen 4Mrd zeiger, mit byteweisem zugriff macht 32GB
							
							der typ der vm ist hybrid mit einem  Stack and register–register oder load/store Ansatz, daher gibt es neben outofmemory fehler auch stackoverflow fehler, das heißt der speicher der vm ist in heap und stack aufgeteilt
							
							es gibt eine spezifikation damit es möglich ist verschiedene implementierungen den gleichen code ausführen können, war bei der entwicklung in 90ern auch das ziel von SUN, das ein programm nur einmal erzeugt werden muss und dann auf verschiedener hardware ausgeführt werden kann, davor musste es für jede archtitekur kompiliert werden oder konnte mit niedriger performanz nur interpretiert werden und jeweils im programm die os spezifischen unterschiede behandelt werden
							
							die spezifikation schreibt z.b. vor welche ausführbaren daten sog. klassen geladen werden müssen bzw. wie das format dieser daten zu sein hat
							
							es sind aber nicht alle themen in der spezifikation behandelt, z.b. ob es einer garbage collection gibt und wie diese arbeiten soll, das ist teil einer konkreten implementierung
							
							
							Process virtual machines are designed to execute computer programs in a platform-independent environment.
							
							drei schlüssel aufgaben
							
							
							    Loading: finds and imports the binary data for a type
							    Linking: performs verification, preparation, and (optionally) resolution
							        Verification: ensures the correctness of the imported type
							        Preparation: allocates memory for class variables and initializing the memory to default values
							        Resolution: transforms symbolic references from the type into direct references.
							    Initialization: invokes Java code that initializes class variables to their proper starting values.

						</p>
					</aside>
				</section>
				
				<section>
					<h2>Existierende JVM Implementierungen</h2>
					
					<p>Es existieren <a href="https://en.wikipedia.org/wiki/List_of_Java_virtual_machines">über 40 verschiedene JVM Projekte</a>.</p>
					
					<ul>
						<li><a href="https://en.wikipedia.org/wiki/HotSpot">HotSpot</a>
							<ul>
								<li>seit 1999</li>
								<li>seit 13 November 2006 unter GPLv2</li>
								<li>seit Oracle (2010), wird JRockit mit HotSpot zusammengelegt</li>
							</ul>
						</li>
						<li><a href="https://en.wikipedia.org/wiki/OpenJ9">OpenJ9</a></li>
					</ul>
					
					<aside class="notes">
						<p>
							es gibt zwar viele aber die sind nicht im serverbereich interessant bzw nicht mehr
							
							nachfolgend die bekanntesten aus dem Desktop und Serverbereich
							
							* HotSpot von Oracle (hält trademark), seit 1999, verwendet mehrere. verschiedene GCs, enthält verschiedene JITs, seit 13 November 2006 unter GPLv2, dadurch haben sich viele der anderen Projekte erledigt
							* In 2017, J9 became an Eclipse Foundation project under the name OpenJ9, formerly IBM
						</p>
					</aside>
				</section>
				
				<section>
					<h2>Existierende Distributionen</h2>
					
					<section>
						<ul>
							<li>JRE = JVM + Standardklassen + OS spezifische Klassen/Schnittstellen</li>
							<li>JDK = JRE + Compiler + Debugger + Profiler</li>
						</ul>
					</section>
					
					<section>
						<ul>
							<li>OracleJDK</li>
							<li>OpenJDK</li>
							<li>IcedTea</li>
						</ul>
					</section>
					
					<aside class="notes">
						<p>
							licensed and supported by Oracle
							tested with licensed test suite from Oracle but open source
							also open-source build and test system, but same code with additions for example other interpreters Hotspot Zero
						</p>
					</aside>
				</section>
				
				<section>
					<h2>Garbage Collection Motivation</h2>
					
					<ul>
						<li>Einfachheit</li>
						<li>Sicherheit</li>
						<li>Performance</li>
					</ul>
					
					<aside class="notes">
						<p>
							All objects* (except some strings) are created and stored on the heap

							garbage collection is a process to automatically free the space on the heap which is no longer needed
							
							different strategies to implement this process
							
							an object is no longer needed when the object is no longer referenced or only weakly referenced or is only referenced by objects that are no longer needed
						
							ziel von java war es unter anderem eine einfach aber performante laufzeitumgebung zu schaffen
							
							vermutlich steigert es sogar effektiv die performance, genau wie bei compilern von high level languages der compiler in der lage ist optimierungen zu finden die der normale programmierer nicht gefunden hätte
							
							außerdem erleitert es die programmierung im sinne von kognitiver last und sicherheits aspekten
						</p>
					</aside>
				</section>
				
				<section>
					<h2>Probleme in der Praxis</h2>
					<section>
						<p>Eigentlich keine, aber...</p>
						
						<ul>
							<li>finalize</li>
							<li>stop the world pauses</li>
						</ul>
						
						<p>=>Abwägung zwischen Durchsatz und Latenz</p>
	
						
						<aside class="notes">
							<p>
								resource finalize is a programming issue
								
								stop the world, can always happen regarding the following, but the time it will cause can be reduced by different strategies
							</p>
						</aside>
					</section>
					
					<section>
						<table class="jvm">
							<tr>
								<td colspan="2" class="gc-used"></td>
								<td colspan="5" class="gc-used"></td>
								<td colspan="3" class="gc-used"></td>
								<td colspan="4" class="gc-used"></td>
							</tr>
							<tr>
								<td colspan="1" class="gc-used"></td>
								<td colspan="5" class="gc-used"></td>
								<td colspan="1" class="gc-used"></td>
								<td colspan="1" class="gc-used"></td>
								<td colspan="5" class="gc-used"></td>
								<td colspan="1" class="gc-free"></td>
							</tr>
						</table>
						
						<aside class="notes">
							<p>
								nehmen wir an der heap ist relativ voll, aber alle objekte haben darin platz
							</p>
						</aside>
					</section>
					
					<section>
						<table class="jvm">
							<tr>
								<td colspan="2" class="gc-garbage"></td>
								<td colspan="5" class="gc-used"></td>
								<td colspan="3" class="gc-garbage"></td>
								<td colspan="4" class="gc-used"></td>
							</tr>
							<tr>
								<td colspan="1" class="gc-garbage"></td>
								<td colspan="5" class="gc-used"></td>
								<td colspan="1" class="gc-garbage"></td>
								<td colspan="1" class="gc-used"></td>
								<td colspan="5" class="gc-used"></td>
								<td colspan="1" class="gc-free"></td>
							</tr>
						</table>
						
						<aside class="notes">
							<p>
								im verlauf des programms werden einige objekte zu garbage
							</p>
						</aside>
					</section>
					

					
					
					<section>
						<table class="jvm">
							<tr>
								<td colspan="2" class="gc-free"></td>
								<td colspan="5" class="gc-used"></td>
								<td colspan="3" class="gc-free"></td>
								<td colspan="4" class="gc-used"></td>
							</tr>
							<tr>
								<td colspan="1" class="gc-free"></td>
								<td colspan="5" class="gc-used"></td>
								<td colspan="1" class="gc-free"></td>
								<td colspan="1" class="gc-used"></td>
								<td colspan="5" class="gc-used"></td>
								<td colspan="1" class="gc-free"></td>
							</tr>
						</table>
						
						<aside class="notes">
							<p>
								und können wieder freigegeben werden
								
								was passiert wenn jetzt ein neues objekt der größe "5" angelegt werden soll
							</p>
						</aside>
					</section>
					
					<section>
						<table class="jvm">
							<tr>
								<td colspan="5" class="gc-used"></td>
								<td colspan="5" class="gc-used"></td>
								<td colspan="4" class="gc-used"></td>
							</tr>
							<tr>
								<td colspan="5" class="gc-used"></td>
								<td colspan="1" class="gc-used"></td>
								<td colspan="8" class="gc-free"></td>
							</tr>
						</table>
						
						<aside class="notes">
							<p>
								der speicher ist vorhanden muss aber kompakter gemacht werden
								
								das fragmentierungs problem ist wichtig, cms ignoriert das z.b. vollständig
							</p>
						</aside>
					</section>
					
				</section>
				
				<section>
					<h2>Warum so wichtig?</h2>
					
					<p>Kurz gesagt: <a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahls Law</a></p>
					
					<p>
						<img src="img/amdahls-law.png" /><br />
						<small>Bild von <a href="https://docs.oracle.com/javase/9/gctuning/introduction-garbage-collection-tuning.htm">Oracle.com</a></small>
					</p>
					
					<aside class="notes">
						<p>
							je mehr die anzahl der prozessoren zunimmt desto schlimmer werden die stop the world pauses
						</p>
					</aside>
				</section>
				
				<section>
					<h2>Memory Structure: Heap und Stack</h2>
					
					<img src="img/jvm-simple-memory-structure.svg" />
					
					<aside class="notes">
						<p>
							vom allgemeinen zum speziellen (hotspot)

							stack und register basiert (register auf grund von performance da computer einfach so gebaut sind)
							
							stack per thread, contains thread local primitives, can also contain objects if jvm is sure that it's not used in another thread and the existence is only local
							
							ein teil des heap ist aber auch pro thread reserviert
							
							gc läuft auf heap, aber nur auf teil abhängig von version
						</p>
					</aside>
				</section>
				
				<section>
					<h2>Memory Structure: weak generational hypothesis</h2>
					
					<section>
						<p>
							<img src="img/generational-hypothesis.png" /><br />
							<small>Bild von <a href="https://dzone.com/articles/how-tame-java-gc-pauses">DZone</a></small>
						</p>
						
						<aside class="notes">
							<p>
								young objects die earlier
	
								young space daher sehr effizient garbage collectable, lebendige objekte sind schwieriger
							</p>
						</aside>
					</section>
					
					<section>
						<p>
							<img src="img/jvm7-heap-model.jpg" /><br />
							<small>Bild von <a href="https://dzone.com/articles/java-memory-architecture-model-garbage-collection">DZone</a></small>
						</p>
						
						<aside class="notes">
							<p>
								PermGenSpace to MetaSpace
							</p>
						</aside>
					</section>
				</section>
				
				<section>
					<h2>HotSpot Collectors</h2>
					
					<section>
						<ul>
							<li>vor Java5 serialGC</li>
							<li>seit Java5 Standard parallelGC</li>
							<li>seit Java5 ergonomics</li>
							<li>seit Java6 cmsGC</li>
							<li>seit Java7 G1GC</li>
							<li>seit Java9 Standard G1GC</li>
						</ul>
						
						<aside class="notes">
							<p>
								decided by gctuning ergonomics, standard for 64bit x86 machines
							</p>
						</aside>
					</section>
					
					<section>
						<h3>Serial/Parallel GC</h3>
						<p>
							<img src="img/jvm-serial-parallel-gc.png" /><br />
							<small>Bild von <a href="https://www.cubrid.org/blog/understanding-java-garbage-collection">cubrid.org</a></small>
						</p>
						
						<aside class="notes">
							<p>
								serialGC immer noch verwendet und am effizientesten für heaps kleiner 100MB, ist aber bei solr installationen nicht immer unbedingt der fall
								
								parallel best throughput, but can have long pauses 99:1
							</p>
						</aside>
					</section>
					
					<section>
						<h3>CMS GC</h3>
						<p>
							<img src="img/jvm-cms-gc.png" /><br />
							<small>Bild von <a href="https://www.cubrid.org/blog/understanding-java-garbage-collection">cubrid.org</a></small>
						</p>
						
						<aside class="notes">
							<p>
								cms can have low pauses, is not compacting
							</p>
						</aside>
					</section>
					
					<section>
						<h3>G1 GC</h3>
						<p>
							<img src="img/jvm-g1-gc.png" /><br />
							<small>Bild von <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#heap_division_by_g1">oracle.com</a></small>
						</p>
						
						<aside class="notes">
							<p>
								g1 also low pauses but better throughput goal 9:1
							</p>
						</aside>
					</section>

					
				</section>
				
				<section>
					<h2>Other Collectors</h2>
					
					<ul>
						<li>OpenJ9</li>
						<li>Azul (pauseless)</li>
						<li><a href="https://wiki.openjdk.java.net/display/shenandoah/Main">Shenandoah</a> (zukünftig)</li>
					</ul>
					
					<aside class="notes">
						<p>
							OpenJ9 mit Optimierungen für spezielle IBM Hardware, ansonsten ähnlich
							
							Azul, hat keine Pausen, in der Theorie, wie kann das sein, lief früher nur auf bestimmter hardware und jetzt glaub ich nur auf linux x86
						
							wird für zukünftige HotSpot entwickelt, wird auch keine Pausen haben
						</p>
					</aside>
				</section>
				
				<section>
					<h2>Solr Configuration</h2>

					<section>
						<p>Von einem aktuellen Solr 7.1</p>
						
						<pre><code class="bash" data-trim>
# Establish default GC logging opts if no env var set (otherwise init to sensible default)
if [ -z ${GC_LOG_OPTS+x} ]; then
  if [[ "$JAVA_VER_NUM" &lt; "9" ]] ; then
    GC_LOG_OPTS=('-verbose:gc' '-XX:+PrintHeapAtGC' '-XX:+PrintGCDetails' \
                 '-XX:+PrintGCDateStamps' '-XX:+PrintGCTimeStamps' '-XX:+PrintTenuringDistribution' \
                 '-XX:+PrintGCApplicationStoppedTime')
  else
    GC_LOG_OPTS=('-Xlog:gc*')
  fi
else
  GC_LOG_OPTS=($GC_LOG_OPTS)
fi
						</code></pre>
						
						<aside class="notes">
							<p>
								solr GC logging configuration
							</p>
						</aside>
					</section>
					
					<section>
						<pre><code class="bash" data-trim>
# if verbose gc logging enabled, setup the location of the log file and rotation
if [ "$GC_LOG_OPTS" != "" ]; then
  if [[ "$JAVA_VER_NUM" &lt; "9" ]] ; then
    gc_log_flag="-Xloggc"
    if [ "$JAVA_VENDOR" == "IBM J9" ]; then
      gc_log_flag="-Xverbosegclog"
    fi
    GC_LOG_OPTS+=("$gc_log_flag:$SOLR_LOGS_DIR/solr_gc.log" '-XX:+UseGCLogFileRotation' '-XX:NumberOfGCLogFiles=9' '-XX:GCLogFileSize=20M')
  else
    # http://openjdk.java.net/jeps/158
    for i in "${!GC_LOG_OPTS[@]}";
    do
      # for simplicity, we only look at the prefix '-Xlog:gc'
      # (if 'all' or multiple tags are used starting with anything other then 'gc' the user is on their own)
      # if a single additional ':' exists in param, then there is already an explicit output specifier
      GC_LOG_OPTS[$i]=$(echo ${GC_LOG_OPTS[$i]} | sed "s|^\(-Xlog:gc[^:]*$\)|\1:file=$SOLR_LOGS_DIR/solr_gc.log:time,uptime:filecount=9,filesize=20000|")
    done
  fi
fi
						</code></pre>
						
						<aside class="notes">
							<p>
								solr GC file rotation
							</p>
						</aside>
					</section>
					
					<section>
						<pre><code class="bash" data-trim>
JAVA_MEM_OPTS=()
if [ -z "$SOLR_HEAP" ] &amp;&amp; [ -n "$SOLR_JAVA_MEM" ]; then
  JAVA_MEM_OPTS=($SOLR_JAVA_MEM)
else
  SOLR_HEAP="${SOLR_HEAP:-512m}"
  JAVA_MEM_OPTS=("-Xms$SOLR_HEAP" "-Xmx$SOLR_HEAP")
fi

# Pick default for Java thread stack size, and then add to SOLR_OPTS
if [ -z ${SOLR_JAVA_STACK_SIZE+x} ]; then
  SOLR_JAVA_STACK_SIZE='-Xss256k'
fi
SOLR_OPTS+=($SOLR_JAVA_STACK_SIZE)
						</code></pre>
						
						<aside class="notes">
							<p>
								solr has a default heap and stack size, might not be a good idea
							</p>
						</aside>
					</section>
					
					<section>
						<pre><code class="bash" data-trim>
# define default GC_TUNE
if [ -z ${GC_TUNE+x} ]; then
    GC_TUNE=('-XX:NewRatio=3' \
      '-XX:SurvivorRatio=4' \
      '-XX:TargetSurvivorRatio=90' \
      '-XX:MaxTenuringThreshold=8' \
      '-XX:+UseConcMarkSweepGC' \
      '-XX:+UseParNewGC' \
      '-XX:ConcGCThreads=4' '-XX:ParallelGCThreads=4' \
      '-XX:+CMSScavengeBeforeRemark' \
      '-XX:PretenureSizeThreshold=64m' \
      '-XX:+UseCMSInitiatingOccupancyOnly' \
      '-XX:CMSInitiatingOccupancyFraction=50' \
      '-XX:CMSMaxAbortablePrecleanTime=6000' \
      '-XX:+CMSParallelRemarkEnabled' \
      '-XX:+ParallelRefProcEnabled' \
      '-XX:-OmitStackTraceInFastThrow')
else
  GC_TUNE=($GC_TUNE)
fi
						</code></pre>
						
						<aside class="notes">
							<p>
								solr GC tuning parameter
							</p>
						</aside>
					</section>
				</section>
				
				<section>
					<h2>HotSpot Java</h2>
					
					<section>
						<h3>GC</h3>
						
						<ul>
							<li>-XX:+UseConcMarkSweepGC</li>
							<li>-XX:+UseParNewGC</li>
						</ul>
						
						<aside class="notes">
							<ul>
								<li>-XX:+UseConcMarkSweepGC CMS aktivieren, aber ab einem heap von 4-6GB sollte man G1 verwenden</li>
								<li>-XX:+UseParNewGC für die young generation wird immer noch der paralle gc verwendet, eigentlich standard für cms</li>
							</ul>
						</aside>
					</section>
					
					<section>
						<h3>Memory organisation</h3>
						
						<ul>
							<li>-XX:NewRatio=3</li>
							<li>-XX:SurvivorRatio=4</li>
							<li>-XX:TargetSurvivorRatio=90</li>
							<li>-XX:MaxTenuringThreshold=8</li>
							<li>-XX:PretenureSizeThreshold=64m</li>
						</ul>
						
						<aside class="notes">
							<ul>
								<li>-XX:NewRatio=2 standard tradeoff between minor and major gc, more ram can increase this</li>
								<li>-XX:SurvivorRatio=8 sollte eigentlich nicht zum tuning verwendet werden, kann über logging optimal ermittelt werden</li>
								<li>-XX:TargetSurvivorRatio=50 will eine besser auslastung des survivors spaces und damit eine vorzeitige promotion zum tenured space verhindern. man könnte auch -XX:+UseAdaptiveSizePolicy verwenden um das automatisch zu tunen lassen</li>
								<li>-XX:MaxTenuringThreshold=4 standard für CMS, wieviele collections ein objekt überleben muss bevor es in den tenured space kommt</li>
								<li>-XX:PretenureSizeThreshold=0 normalerweise deaktiviert, objekte dieser größe gehen direkt in den tenured spacce</li>
							</ul>
						</aside>
					</section>
					
					<section>
						<h3>Parallel tuning</h3>
						
						<ul>
							<li>-XX:ConcGCThreads=4</li>
							<li>-XX:ParallelGCThreads=4</li>
							<li>-XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=50</li>
							<li>-XX:+CMSParallelRemarkEnabled</li>
							<li>-XX:+ParallelRefProcEnabled</li>
						</ul>
						
						<aside class="notes">
							<ul>
								<li>-XX:ConcGCThreads=4 es gibt keinen eindeutigen default wert</li>
								<li>-XX:ParallelGCThreads=4 es gibt keinen eindeutigen default wert</li>
								<li>-XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=50 macht es etwas berechenbarer wann der CMS angestoßen wird</li>
								<li>-XX:+CMSParallelRemarkEnabled makes sense on multi core</li>
								<li>-XX:+ParallelRefProcEnabled referenzen werden parallel bearbeitet</li>
							</ul>
						</aside>
					</section>
					
					<section>
						<h3>Sonstiges</h3>
						
						<ul>
							<li>-XX:CMSMaxAbortablePrecleanTime=6000</li>
							<li>-XX:-OmitStackTraceInFastThrow</li>
							<li>-XX:+CMSScavengeBeforeRemark</li>
						</ul>
						
						<aside class="notes">
							<ul>
								<li>-XX:CMSMaxAbortablePrecleanTime=6000 no idea and the default is 5000?</li>
								<li>-XX:-OmitStackTraceInFastThrow zwingt jvm dazu immer die stacktraces zu erhalten</li>
								<li>-XX:+CMSScavengeBeforeRemark versucht die abhängigkeiten zwischen tenured und young zu verkleinern indem immer vor major ein minor gc durchgeführt wird</li>
							</ul>
						</aside>
					</section>
				</section>

				<section>
					<h2>Empfehlung</h2>
					
					<section>
						<h3>CMS</h3>
						
						<ul>
							<li>gut konfiguriert</li>
							<li>tuning Heap organisation</li>
						</ul>
						<aside class="notes">
							<p>
								wird für zukünftige HotSpot entwickelt, wird auch keine Pausen haben, aber für Server nicht so wichtig
							</p>
						</aside>
					</section>
					
					<section>
						<h3>G1</h3>
						
						<ul>
							<li>für Heaps größer 6GB</li>
							<li>maximale Latenz</li>
							<li>wenig getestet</li>
						</ul>
						
						<aside class="notes">
							<p>
								Do not, under any circumstances, run Lucene with the G1 garbage collector. Lucene's test suite fails with the G1 garbage collector on a regular basis, including bugs that cause index corruption. There is no person on this planet that seems to understand such bugs (see https://bugs.openjdk.java.net/browse/JDK-8038348, open for over a year), so don't count on the situation changing soon. This information is not out of date, and don't think that the next oracle java release will fix the situation. 
							</p>
						</aside>
					</section>
					
					<section>
						<h3>G1</h3>
						
						<pre><code class="bash" data-trim>
JVM_OPTS=" \
	-XX:+UseG1GC \
	-XX:+ParallelRefProcEnabled \
	-XX:G1HeapRegionSize=8m \
	-XX:MaxGCPauseMillis=200 \
	-XX:+UseLargePages \
	-XX:+AggressiveOpts \
"
						</code></pre>
						
						<p>
							Quelle: <a href="https://wiki.apache.org/solr/ShawnHeisey#G1_.28Garbage_First.29_Collector">Solr Wiki</a>
						</p>
						<aside class="notes">
							<p>
								Do not, under any circumstances, run Lucene with the G1 garbage collector. Lucene's test suite fails with the G1 garbage collector on a regular basis, including bugs that cause index corruption. There is no person on this planet that seems to understand such bugs (see https://bugs.openjdk.java.net/browse/JDK-8038348, open for over a year), so don't count on the situation changing soon. This information is not out of date, and don't think that the next oracle java release will fix the situation. 
							</p>
						</aside>
					</section>
				</section>
				
				<section>
					<h2>Zukunft: Analyse</h2>
					
					<ul>
						<li>Crash</li>
						<li>Hänger</li>
						<li>Out of memory</li>
						<li>Performance</li>
						<li>Alternative GCs</li>
						<li>Fusion default config</li>
					</ul>
					
					<aside class="notes">
						<p>
							Welche Fragestellungen sind in Zukunft am wichtigsten?
						</p>
					</aside>
				</section>
				
				<section>
					<h2>Danke!</h2>
				
				</section>
				
				<section>
					<h2>Referenzen</h2>
				
					<ul>
						<li><a href="https://en.wikipedia.org/wiki/Java_virtual_machine">https://en.wikipedia.org/wiki/Java_virtual_machine</a></li>
						<li><a href="https://en.wikipedia.org/wiki/Virtual_machine">https://en.wikipedia.org/wiki/Virtual_machine</a></li>
						<li><a href="https://en.wikipedia.org/wiki/List_of_Java_virtual_machines">https://en.wikipedia.org/wiki/List_of_Java_virtual_machines</a></li>
						<li><a href="https://en.wikipedia.org/wiki/HotSpot">https://en.wikipedia.org/wiki/HotSpot</a></li>
						<li><a href="https://en.wikipedia.org/wiki/OpenJ9">https://en.wikipedia.org/wiki/OpenJ9</a></li>
						<li><a href="https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines">https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines</a></li>
						<li><a href="https://en.wikipedia.org/wiki/List_of_JVM_languages">https://en.wikipedia.org/wiki/List_of_JVM_languages</a></li>

						<li><a href="https://www.azul.com/resources/azul-technology/azul-c4-garbage-collector/">https://www.azul.com/resources/azul-technology/azul-c4-garbage-collector/</a></li>
						<li><a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html">http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html</a></li>

						<li><a href="https://www.onlinedigitallearning.com/mod/lesson/view.php?navbutton=Next+activity%3A+Identifying+a+sluggish+JVM&id=15475">https://www.onlinedigitallearning.com/mod/lesson/view.php?navbutton=Next+activity%3A+Identifying+a+sluggish+JVM&amp;id=15475</a></li>

						<li><a href="https://dzone.com/articles/java-8-permgen-metaspace">https://dzone.com/articles/java-8-permgen-metaspace</a></li>

						<li><a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a></li>

						<li><a href="https://dzone.com/articles/java-8-permgen-metaspace">https://dzone.com/articles/java-8-permgen-metaspace</a></li>
						<li><a href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html">http://tutorials.jenkov.com/java-concurrency/java-memory-model.html</a></li>
						<li><a href="https://dzone.com/articles/java-memory-architecture-model-garbage-collection">https://dzone.com/articles/java-memory-architecture-model-garbage-collection</a></li>

						<li><a href="https://docs.oracle.com/javase/1.5.0/docs/guide/vm/gc-ergonomics.html">https://docs.oracle.com/javase/1.5.0/docs/guide/vm/gc-ergonomics.html</a></li>
						<li><a href="https://www.cubrid.org/blog/understanding-java-garbage-collection">https://www.cubrid.org/blog/understanding-java-garbage-collection</a></li>

						<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html</a></li>
						<li><a href="https://docs.oracle.com/javase/9/gctuning/ergonomics.htm">https://docs.oracle.com/javase/9/gctuning/ergonomics.htm</a></li>
					
						<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html</a></li>
						<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html</a></li>
						<li><a href="https://wiki.apache.org/solr/ShawnHeisey">https://wiki.apache.org/solr/ShawnHeisey</a></li>
						<li><a href="https://blogs.oracle.com/poonam/understanding-cms-gc-logs">https://blogs.oracle.com/poonam/understanding-cms-gc-logs</a></li>
						<li><a href="https://blogs.oracle.com/jonthecollector/what-the-hecks-a-concurrent-mode">https://blogs.oracle.com/jonthecollector/what-the-hecks-a-concurrent-mode</a></li>
						<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></li>
					</ul>

				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				history: true,
				
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'socket.io/socket.io.js', async: true },
					{ src: 'plugin/notes-server/client.js', async: true }
				]
			});
		</script>
	</body>
</html>
