<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Distances, ads and other esoteric stuff</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/custom.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Distances, ads and other esoteric stuff</h1>
					<aside class="notes">
						<p>Herzlich willkommen. Gleich vorweg, der Vortrag ist schamlose Werbung für eine App. Die App wurde unteranderem an der letzten Weihnachtsfeier gebrainstormt. Ich hoffe dieses Jahr können wir den Teil mit dem Geld besprechen. Mehr sei aber noch nicht verraten. Links gibt es am Ende. Zunächst soll es um die folgenden Dinge gehen: Distances, ads and other esoteric stuff.</p>
						<p>Inhalt des Vortrags ist theoretischer Natur, wird aber versucht mit praktischen Beispielen und Problem näher gebracht.</p>
					</aside>
				</section>
				
				<section>
					<h2>What is <em>distance</em>?</h2>

					<dl>
						<dt>
							<dfn>
								<a href="https://en.wikipedia.org/wiki/Distance">Distance</a>
							</dfn>
						</dt>
						<dd>
							...is a numerical <em>measurement</em> of how far apart objects or points are.
						</dd>
					</dl>

					<aside class="notes">
						General, we go into details with more concrete examples in a second. Measurement is important because then we can compare it. This means the measurement converts it into a number.
						We'll ignore the "far apart" stuff as this is more philosophical.
					</aside>
				</section>
				
				<section>
					<h2>Where is it used?</h2>

					<ul>
						<li>Math (Geometry, Algebra, Statistics)</li>
						<li>Physics</li>
						<li>Geography</li>
						<li>Language (Search, NLP, similarity)</li>
						<li>Computer science (error correction codes)</li>
						<li>Marketing (Ads)</li>
					</ul>

					<aside class="notes">
						<p>
						We'll look into concrete examples, just wanted to show the breadth of the distance term. Maths, physics and geography probably come naturally to mind.
						</p>
						<p>But also in language there are a lot of topics and games, like word ladder.</p>
						<p>Marketing is using distances cluster group of data points (humans) in certain categories and the sell stuff to them.</p>
					</aside>
				</section>
				
				<section>
					<section>
						<h2>Geometric-Distance</h2>
						<p>
							<img alt="Geometric distance" src="images/manhattan_distance.svg" />
						</p>
						
						<ul>
							<li>Manhattan distance</li>
							<li>Euclidean distance</li>
						</ul>
						
						<aside class="notes">
							These are probably the most common and known distance metrics. 
						</aside>
					</section>
					
					<section>
						<h3>Manhattan distance</h3>

						<img alt="Geometric distance" src="images/manhattan_distance.svg" />

						<p>number of blocks to walk</p>
						
						<div style="position:relative; width:640px; height:200px; margin:0 auto;">
							<div class="fragment fade-out" width="640" height="200" style="position:absolute;top:0;left:0;">
							\[\begin{aligned}
							d(p,q) = (|p_{x} - q_{x} |) + (|p_{y} - q_{y} |)
							\end{aligned} \]
							</div>
							<div class="fragment" width="640" height="200" style="position:absolute;top:0;left:0;">
							\[\begin{aligned}
							d(p,q) = \sum\limits_{i}{|p_{i} - q_{i} |}
							\end{aligned} \]
							</div>
						</div>
						
						

						<aside class="notes">
							with "i" we walk over the dimensions of the points, so this can be any dimension
						</aside>
					</section>
					
					<section>
						<h3>Euclidean distance</h3>

						<img alt="Geometric distance" src="images/manhattan_distance.svg" />

						<p>as the crow flies</p>
						
						<p>
						\[ \begin{aligned}
						d(p,q) = \sqrt{\sum\limits_{i}{(p_{i} - q_{i})^{2}}}
						\end{aligned} \]
						</p>

						<aside class="notes">
							so there is also no limit on two dimensions, this works in three and higher dimensions
						</aside>
					</section>
					
					<section>
						<h3>Norm</h3>

						<p>
						\[ \begin{aligned}
						d_{k} (p,q) = \sqrt[k]{\sum\limits_{i}{|p_{i} - q_{i}|^{k}}}
						\end{aligned} \]
						</p>
						
						<p>for all k>0</p>

						<aside class="notes">
							mathematically this is generalized under the term Norm
							we'll get back to this later
						</aside>
					</section>
				</section>
				
				<section>
					<section>
						<h2>
						<a href="https://en.wikipedia.org/wiki/Great-circle_distance">Great-circle distance</a>
						</h2>
						
						<p>
						<img alt="Geometric distance" src="images/illustration_of_great-circle_distance.svg" />
						</p>
						
						<p>
						\[\begin{aligned}
						d(\lambda_1, \phi_1,\lambda_2, \phi_2) = 
						\end{aligned} \]
						\[\begin{aligned}
						r * \arccos\bigl(\sin\phi_1\sin\phi_2 + \cos\phi_1\cos\phi_2\cos(\Delta\lambda)\bigr)
						\end{aligned} \]
						</p>
						
						<aside class="notes">
							<p>a more real "world" example</p>
							<p>with the earth here we have a three dimensional sphere but we want to find the distance of two points on the two dimensional surface</p>
							<p>so viel sei schon mal verraten in der App geht es darum sich mit anderen Menschen zu treffen (im RealLife(TM)), daher ein kleiner Exkurs wie ich das implementiert habe</p>
						</aside>
					</section>
					
					<section>
						<h2>What I did</h2>
						
						<pre><code class="hljs" data-trim data-noescape>
CREATE FUNCTION get_distance_in_meters_between_geo_locations(
  geo1_latitude DOUBLE, geo1_longitude DOUBLE,
  geo2_latitude DOUBLE, geo2_longitude DOUBLE
) RETURNS decimal(20,10) DETERMINISTIC
BEGIN
  return 1000 * 6371 *
    acos(
        cos(radians(geo1_latitude)) *
        cos(radians(geo2_latitude)) *
        cos(radians(geo1_longitude) -
            radians(geo2_longitude)
        ) +
        sin(radians(geo1_latitude)) *
        sin(radians(geo2_latitude))));
						</code></pre>
						
						<aside class="notes">
							einfach mal in SQL bauen,
							wenn man die Koordinaten  in einer Datenbanktabelle hat kann man die Tabelle einfach auf sich selbst joinen und den Abstand für alle berechnen und dann sotieren
						</aside>
					</section>
					
					<section>
						<h2>What I should do</h2>
						
						<p>
							<blockquote>...the spherical law of cosines formula can have large rounding errors if the distance is small</blockquote>
							
							<img src="images/akward-monkey-looking.jpg" class="scaled-img"/>
						</p>
						
						<p>
							<a href="https://en.wikipedia.org/wiki/Haversine_formula">Haversine formula</a>
						</p>
						
						<aside class="notes">
							wäre eine triviale Verbesserung, aber...
						</aside>
					</section>
					
					<section>
						<h2>What I should do</h2>
						
						<p>
							<blockquote>...are based on the assumption that the figure of the Earth is an oblate spheroid</blockquote>
							
							<img src="images/akward-monkey-looking.jpg" class="scaled-img"/>
						</p>
						<p>
							<a href="https://en.wikipedia.org/wiki/Vincenty%27s_formulae">Vincenty's formula</a>
						</p>
						
						<aside class="notes">
							funktioniert auch für elipsoide, wie die Erde, aber schwierig in SQL zu implementieren (iterativ)
						</aside>
					</section>
					
					<section>
						<h2>What I should do</h2>
						
						<p>
							<a href="https://ericandrewlewis.github.io/how-a-quadtree-works/">Don't calculate it for all points:</a><br />
							<img src="images/quadtree.png" class="scaled-img"/>
						</p>
						
						<a href="https://en.wikipedia.org/wiki/Quadtree">Quadtrees</a>
						
						<aside class="notes">
							there are techniques to map this to databases: https://en.wikipedia.org/wiki/Z-order_curve
							wenn wir schon bei Optimierung sind,
							wenn man den nächsten Punkt finden will muss man nicht unbedingt den Abstand zu allen bestimmen wenn man eine entsprechende Datenstruktur verwendet
							Datenstruktur die effizient den nächsten Nachbar finden kann.
							Wird in spielen verwendet und bei Bilder.
						</aside>
					</section>
					
					<section>
						<h2>What I really should do</h2>
						
						<p>Not using <a href="https://jira.mariadb.org/browse/MDEV-13467">MariaDB</a></p>
						
						<p>For other reasons I need more than the nearest point</p>
						
						<pre><code class="hljs" data-trim data-noescape>
SELECT ST_AsText(geom), city
FROM person.address
ORDER BY geom &lt;-&gt; 'POINT(-121.626 47.8315)'
FETCH FIRST 7 ROWS ONLY;
						</code></pre>
						
						<a href="https://postgis.net/docs/geometry_distance_knn.html">PostGIS kNN</a>
						
						<aside class="notes">
							Use the proper tool, don't implement it
							postgis hat auch Funktionen zum Abstand auf einer Kugel oder einem Elipsoid zu bestimmen
						</aside>
					</section>
					
					
				</section>
				
				<section>
					<h2>Compass and web apps</h2>
					
					<section>
						<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Detecting_device_orientation">Device orientation</a></p>
						
						<pre><code class="hljs" data-trim data-noescape>
						window.addEventListener("deviceorientation",
							handleOrientation);
						
						function handleOrientation(event) {
							var absolute = event.absolute;
							var alpha    = event.alpha;
							var beta     = event.beta;
							var gamma    = event.gamma;
						}
						</code></pre>
						
						<aside class="notes">
							a missing feature
						</aside>
					</section>
					
					<section>
						<dl>
							<dt><a href="https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/absolute">absolute=northbound</a></dt>  
							<dd>On return, absolute is true if the orientation data in instanceOfDeviceOrientationEvent is provided as the difference between the Earth's coordinate frame and the device's coordinate frame, or false if the orientation data is being provided in reference to some arbitrary, device-determined coordinate frame.</dd>
						</dl>
						
						<aside class="notes">
							northbound is nowadays, a missing feature, it was removed for multiple reasons
							better VR/AR and web compatability with safari
						</aside>
					</section>
					
					<section>
						<p>Spoiler and confusion</p>
						
						<ul>
							<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/ondeviceorientationabsolute">MDN</a></li>
							<li><a href="https://w3c.github.io/deviceorientation/spec-source-orientation.html#deviceorientationabsolute">W3C</a></li>
						</ul>
						
						<aside class="notes">
							solution consensus from the Chrome dev was to create a new event, but according to MDN it's not supported and non standard
							
							according to W3C it is, maybe somebody can explain this to me later
						</aside>
					</section>
					
					<section>
						
						<img src="images/new-project.jpg" />
						<p>Idea: <em>just</em> calculate it yourself!</p>
						
						<aside class="notes">
							back to the topic, as I was not aware of this functionality
							the idea is, if I have the current gps locations and the current relative position i can infer the absolute orientation with multiple data points
							in the following I'll describe the high level approach and the building blocks
						</aside>
					</section>
				</section>
				
				<section>
					<h2>Hobocompass</h2>
					
					<svg height="500" width="500">
						<line x1="250" y1="500" x2="250" y2="20" class="arrow base" />
						
						<g class="fragment">
							<line x1="245" y1="500" x2="245" y2="300" class="arrow odd" />
							<line x1="255" y1="400" x2="255" y2="200" class="arrow even" />
							<line x1="245" y1="300" x2="245" y2="100" class="arrow odd" />
							<line x1="255" y1="200" x2="255" y2="020" class="arrow even" />
						</g>
						<g class="fragment fade-in-then-out">
							<text x ="250" y ="480" style="transform: rotate(45deg);" class="phone">📱</text>
							<text x ="250" y ="350" style="transform: rotate(30deg);" class="phone">📱</text>
						</g>
						<g class="fragment fade-in">
							<text x ="250" y ="400" style="transform: rotate(38deg);" class="phone">📱</text>
						</g>
						<g class="fragment fade-in-then-out">
							<text x ="250" y ="380" style="transform: rotate(45deg);" class="phone">📱</text>
							<text x ="250" y ="250" style="transform: rotate(30deg);" class="phone">📱</text>
						</g>
						<g class="fragment fade-in">
							<text x ="250" y ="300" style="transform: rotate(38deg);" class="phone">📱</text>
						</g>
						<g class="fragment fade-in-then-out">
							<text x ="250" y ="280" style="transform: rotate(45deg);" class="phone">📱</text>
							<text x ="250" y ="150" style="transform: rotate(30deg);" class="phone">📱</text>
						</g>
						<g class="fragment fade-in">
							<text x ="250" y ="200" style="transform: rotate(38deg);" class="phone">📱</text>
						</g>
						<g class="fragment fade-in-then-out">
							<text x ="250" y ="180" style="transform: rotate(45deg);" class="phone">📱</text>
							<text x ="250" y ="050" style="transform: rotate(30deg);" class="phone">📱</text>
						</g>
						<g class="fragment fade-in">
							<text x ="250" y ="100" style="transform: rotate(38deg);" class="phone">📱</text>
						</g>
					</svg>
					
					<aside class="notes">
						measure some distance walking with its geographic information and phone orientation
						
						split the distance into overlapping chunks
						
						average the orientation of the phone over a chunk, now you have and estimation where north is relative the phone orientation
						
						this is assumption 1) the average is reasonable value for this chunk
						
						to make sure the orientation of the phone is sane we compare it with the next chunk
						
						the idea is that it's overlapping it should be similar
						
						you take this difference score over multiple chunks and you deem it safe enough
						
						how did I come up with this
						just looked what worked, sampling and sliding window
						
						pros:
						* it evolved like this
						* but sliding window is good not all data is important, just the most recent, dont carry arround wrong old data, ignore aussreisser
						
						cons: 
						* slow to start
						* could be faster
						* can run into wrong optimum and not recover from it
						* no theoretical explanation
					</aside>
				</section>
				
				<section>
					<h2>Angle/arc average</h2>
					
					<svg height="500" width="500">
						<circle cx="250" cy="250" r="2" class="point"/>
						
						<path class="arc odd" d="M 380,100 A 200,200 0 0 1 450,250" />
						
						<g class="fragment fade-in-then-out" data-fragment-index="0">
							<circle cx="347" cy="77" r="2" class="point"/>
						</g>
						<g class="fragment fade-in-then-out" data-fragment-index="0">
							<path class="arc even" d="M 315,60 A 200,200 0 0 1 450,250" />
						</g>
						
						<g class="fragment fade-in-then-out" data-fragment-index="1">
							<path class="arc even" d="M 50,250 A 200,200 0 0 1 450,250" />
							<path class="arc even" d="M 120,400 A 200,200 0 0 1  50,250" />
						</g>
						
						<g class="fragment fade-in-then-out" data-fragment-index="2">
							<path class="arc even" d="M 50,250 A 200,200 0 0 1 450,250" />
							<path class="arc even" d="M 120,400 A 200,200 0 0 1  50,250" />
						</g>
						
						<g class="fragment fade-in-then-out" data-fragment-index="2">
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(40deg);" class="arrow rotation" />
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(220deg);" class="arrow rotation" />
						</g>
						
						<g class="fragment" data-fragment-index="3">
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(40deg);" class="arrow rotation" />
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(20deg);" class="arrow rotation" />
						</g>
						
						<g class="fragment" data-fragment-index="4">
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(30deg);" class="arrow rotation average" />
						</g>
						
						<g class="fragment" data-fragment-index="5">
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(60deg);" class="arrow rotation" />
						</g>
					</svg>
					
					<aside class="notes">
						For the orientation of the phone per chunk we need to average this.
						
						How to average angles? Imagine we have two different angle we can represent it as two arc, so a sane person would say the average is somewhere in between
						
						What happens if the angle get wider, like for example the extreme on the other side? We could argue that it's perpendicular to the other two but we'll see in a second that doesn't make sense.
						
						How do we efficiently compute this with multiple angles.
						
						The trick is simple, we change the coordinate system and transform the angles to vectors.
					</aside>
				</section>
				
				<section>
					<h2>Angle/arc average</h2>
					
					<svg height="500" width="500">
						<circle cx="250" cy="250" r="200"/>
						
						<g class="fragment fade-in-then-out">
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(20deg);" class="arrow rotation" />
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(40deg);" class="arrow rotation" />
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(60deg);" class="arrow rotation" />
						</g>
						
						<g class="fragment fade-in-then-out">
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(20deg) scale(0.3);" class="arrow rotation" />
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(40deg) scale(0.3);" class="arrow rotation" />
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(60deg) scale(0.3);" class="arrow rotation" />
						</g>
						
						<g class="fragment fade-in">
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(20deg) scale(0.3);" class="arrow rotation" />
							<line x1="250" y1="250" x2="250" y2="50" style="transform: translate(20px, -55px) rotate(40deg) scale(0.3);" class="arrow rotation" />
							<line x1="250" y1="250" x2="250" y2="50" style="transform: translate(60px, -102px) rotate(60deg) scale(0.3);" class="arrow rotation" />
						</g>
						
						<g class="fragment fade-in">
							<line x1="250" y1="250" x2="355" y2="128" class="arrow rotation" />
						</g>
					</svg>
					
					<p><a href="https://en.wikipedia.org/wiki/Norm_(mathematics)">Euclidean norm</a></p>
					
					<aside class="notes">
						This solves the issue how to add multiple angles. We just stack the tips on top of each other.
						
						And we get a sane solution for opposite angles as this cancels out the length of the vector and it doesn't make sense to talk about the orientation of a vector of length zero.
					</aside>
				</section>
				
				<section>
					<h2>Error distance</h2>
					
					<svg height="300" width="500">
						<circle cx="250" cy="250" r="200"/>
						
						<g class=" ">
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(20deg) scale(0.3);" class="arrow rotation" />
							<line x1="250" y1="250" x2="250" y2="50" style="transform: translate(20px, -55px) rotate(40deg) scale(0.3);" class="arrow rotation" />
							<line x1="250" y1="250" x2="250" y2="50" style="transform: translate(60px, -102px) rotate(60deg) scale(0.3);" class="arrow rotation" />
						</g>
						
						<g class=" ">
							<line x1="250" y1="250" x2="355" y2="128" class="arrow rotation" />
						</g>
					</svg>
					
					<p>
						\[\begin{aligned}
						\|\mathbf x + \mathbf y\| \leq \|\mathbf x\| + \|\mathbf y\|
						\end{aligned} \]
					</p>
					<p>
						<a href="https://en.wikipedia.org/wiki/Triangle_inequality">Triangle inequality</a>
					</p>
					
					<aside class="notes">
						This length actually gives us more information. Maybe you remember the triangle inequality from school or university.
						
						The sum of the two shorter sides of a triangle is always longer than the longer side.
						
						If we scale our unit vectors two the number of vectors we know for sure that the sum of their length can never be greater then one. This give a quality metric how much the phone was fiddled around in the hand.
						
						If all vector stack on top if each other the result vector is longer. If the phone is twisted and turned a lot the length is shorter. With this information we can make a decision which measurements we should ignore because our assumption of a steady walk does not hold.
					</aside>
				</section>
				
				<section>
					<h2>How should it be done?</h2>
					
					<p class="fragment" data-fragment-index="0">I have no idea. <span class="fragment" data-fragment-index="1">Well some.</span></p>
					
					<ol>
						<li class="fragment" data-fragment-index="1">Linear regression</li>
						<li class="fragment" data-fragment-index="3">ML/AI</li>
					</ol>
					
					<div style="position:relative; width:640px; height:380px; margin:0 auto;">
						<div class="fragment fade-in-then-out" data-fragment-index="0" width="640" height="380" style="position:absolute;top:0;left:0;">
							<img src="images/expanding-brain-1.jpg" />
						</div>
						<div class="fragment fade-in-then-out" data-fragment-index="1" width="640" height="380" style="position:absolute;top:0;left:0;">
							<img src="images/expanding-brain-2.jpg" />
						</div>
						<div class="fragment fade-in-then-out" data-fragment-index="2" width="640" height="380" style="position:absolute;top:0;left:0;">
							<img src="images/linear-regression.svg" />
						</div> 
						<div class="fragment fade-in-then-out" data-fragment-index="3" width="640" height="380" style="position:absolute;top:0;left:0;">
							<img src="images/expanding-brain-3.jpg" />
						</div>
					</div>
					
					<aside class="notes">
						Normally there are some typical approaches from here. We have the assumption that the orientation is related to the walking. So maybe we can use a linear regression.
						pros:
						* could be really fast
						* have a sound basis of the quality of the estimation
						
						But a linear regression is normally for an ordered input. But this is circular.
						
						We have issues when we get to the borders where the data loops, where close value looks like an outlier.
						
						So the simple coordinate transformation does not help here. I'm glad if somebody could this explain further to me.
						
						But as we are talking about linear regression we are already in the realm of ML and AI. Maybe someone has an idea to analyse the hand motion and can extract more data from this.
						
						Anyway there would be more data like gravity sensor and acceleration sensors that could be exploited. I just don't know how to include the data in a model for the prediciton.
					</aside>
				</section>

				<section>
					<h2>Status feature</h2>
					
					<p>
						<ul>
							<li class="fragment">🏐🏆🥇</li>
							<li class="fragment">🎼🎤🎭</li>
							<li class="fragment">🗣️🇫🇷🇩🇪</li>
							<li class="fragment">🍆💦🍑</li>
						</ul>
					</p>
					
					<hr />
					
					<p>
						<ul>
							<li class="fragment">🎤🇫🇷🥇</li>
							<li class="fragment">🎤🎤🎤🇫🇷🥇</li>
						</ul>
					</p>

					<aside class="notes">
						If people are too far away you can't meet them, but maybe you want to have a hint for what they are looking for.
						
						So the app also has a status feature. The status is your status and at the same time what you are looking for.
						Only emojis are valid as input. We can talk about this later. SO how could this look like.
						
						This could be sports. Looks like this is quite competitive.
						A jam session.
						A language exchange
						or helping someone to get his or her fruits and vegies sorted out.
						
						But we don't want to have a catalog to browse through it should match us with the best candidate.
					</aside>
				</section>
				
				<section>
					<h3>Klassische Norm (k=2)</h3>

					<p>
					\[\begin{aligned}
					d_{2} ((🎤🎤🥇),(🏐🏆🥇)) =
					\end{aligned} \]
					</p>
					
					<p>
					\[\begin{aligned}
					= {\sqrt{(🎤-🏐)^{2}}}  + {\sqrt{(🎤-🏆)^{2}}}  + {\sqrt{(🥇-🥇)^{2}}}
					\end{aligned} \]
					</p>

					<aside class="notes">
						We have already seen this approach it should also work here.
						
						We could use the unicode code points fill up missing dimensions if necessary and calculate it
						
						But...
					</aside>
				</section>
				
				<section>
					<h3>Literature</h3>

					<ul>
						<li><a href="https://homes.cs.washington.edu/~pedrod/papers/cacm12.pdf">A few useful things to know about machine Learning</a></li>
						<li><a href="https://bib.dbvis.de/uploadedFiles/155.pdf">On the Surprising Behavior of Distance Metrics in High Dimensional Space</a></li>
					</ul>

					<aside class="notes">
						These metrics lose their meaning in higher dimensions
						
						We get better results with L1 norm and even better ones with L&lt;1 "norms"
					</aside>
				</section>

				<section>
					<h2>What is similarity?</h2>
					
						<p><a href="https://en.wikipedia.org/wiki/Similarity_measure">Wikipedia</a></p>

					<aside class="notes">
						<p>Inverse of the distance on an interval from 0-1, 0 no similarity, 1 total similarity, triangle inequality does no longer hold.</p>
						
					</aside>
				</section>

				<section>
					<section>
						<h2>Textual-Distance</h2>
	
						<ul>
							<li><a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming distance</a></li>
							<li><a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a></li>
							<li><a href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf">tf–idf</a> / <a href="https://en.wikipedia.org/wiki/Okapi_BM25">BM25</a></li>
							<li><a href="https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance">Jaro-Winkler distance</a></li>
						</ul>
	
						<aside class="notes">
							So called <a href="https://en.wikipedia.org/wiki/String_metric">string metrics</a>
	
							<ul>
								<li>Hamming distance, simple for error correcting codes</li>
								<li>Levenshtein distance, uni homework because of dynamic programming</li>
								<li>tf–idf / BM25, are used in elasticsearch, better suited for longer texts good with context</li>
								<li>Jaro-Winkler, simple, works with strings, has a little bit of context</li>
							</ul>
	
							But if you can only meet people in your close vicinity this could get boring. So there should be some way to express yourself.
						</aside>
					</section>
					
					<section>
						<h2>Levenshtein distance</h2>
	
						<ol>
							<li><span class="fragment highlight-red" data-fragment-index="1">k</span>itten → <span class="fragment highlight-red" data-fragment-index="1">s</span>itten</li>
							<li>sitt<span class="fragment highlight-red" data-fragment-index="2">e</span>n → sitt<span class="fragment highlight-red" data-fragment-index="2">i</span>n</li>
							<li>sittin → sittin<span class="fragment highlight-red" data-fragment-index="3">g</span></li>
						</ol>
	
						<aside class="notes">
							So called <a href="https://en.wikipedia.org/wiki/String_metric">string metrics</a>
	
							<ul>
								<li>Hamming distance, simple for error correcting codes</li>
								<li>Levenshtein distance, uni homework because of dynamic programming</li>
								<li>tf–idf / BM25, are used in elasticsearch, better suited for longer texts good with context</li>
								<li>Jaro-Winkler, simple, works with strings, has a little bit of context</li>
							</ul>
	
							But if you can only meet people in your close vicinity this could get boring. So there should be some way to express yourself.
						</aside>
					</section>
					
					<section>
						<h2>Jaro-Winkler distance</h2>

						<p>
						\[
						\begin{aligned} Sim_J (s_1, s_2) = \begin{cases} 0 &\text{if } m = 0, \\ \frac{1}{3}\left( \frac{m}{|s_1|} + \frac{m}{|s_2|} + \frac{m - t}{m} \right) &\text{otherwise}. \end{cases} \end{aligned}
						\]
						</p>

						<p>
						\[
						\left\lfloor \dfrac{\max (|s_1|, |s_2|)}{2} \right\rfloor - 1
						\]
						</p>
	
						<aside class="notes">
						</aside>
					</section>
					<section>
						<h2>Jaro-Winkler distance</h2>
						
						<p>s1=martha, s2=marhta</p>

						<p>
						\[
						\frac{1}{3}\left( \frac{m}{|s_1|} + \frac{m}{|s_2|} + \frac{m - t}{m} \right)
						\]
						</p>

						<p>
						\[
						\frac{1}{3}\left( \frac{6}{|6|} + \frac{6}{|6|} + \frac{6 - 1}{1} \right) = 0,944
						\]
						</p>

						<aside class="notes">
						</aside>
					</section>
				</section>

				<section>
					<h2>What should I do</h2>
					
					<p><a href="https://en.wikipedia.org/wiki/Semantic_similarity">Semantic similarity</a> / 🏐 ≈ 🏀</p>
					
					<blockquote>"All emojis are equal, but some emojis are more equal than others."</blockquote>
					
					<aside class="notes">
						in general the approach is okay, not to many symbols or characters to compare, so a lot of the more complex algorithms don't fit here
						
						because of that reason one could use the information that some emojis are used in the same context
						
						resume, all ingredients together for a dating app.
						It can find the nearest person. Not very effiently but it works.
						It can give you the direction. "Working" on all devices. iPhones not really tested.
						And gives you a "best" match considering the distance to the person.
					</aside>
				</section>

				<section>
					<h2>Resume</h2>

					<ul>
						<li>Geo support</li>
						<li>Custom function support</li>
						<li>Near real time support</li>
					</ul>

					<p>How can I bring my queries in a simple way close to the database?</p>

					<aside class="notes">
						As I have geographic queries and similarity queries I'm not aware of a system that can do both.
						Especially that I want to fine tune the similarity algorithm and would like to avoid writing it all in SQL.

						The application is running on a RaspberyPi like device connect with a USB disk. If a client connects it creates about one query per seconds.
						With twenty clients this is the limits of how many queries this disk can handle. I don't need to have every query committed, a small delay is okay. I don't really need transaction isolation here. Something like near-realtime from Elasticsearch is good enough.

						Is there a backend where I can have the cake and eat it too?
					</aside>
				</section>

				<section>
					<h2>Thanks</h2>
					
					<p><a href="https://ärro.de">https://ärro.de</a></p>
					
					<aside class="notes">
						<p>For anyone who wants to test the app you can now test it here. Feedback is welcome. If you're inside be aware that it's not really working. The cool compass stuff is only active with firefox, but for this you need a good GPS signal. And make sure to have "device only" for your GPS activated otherwise Google holds back with updates of your location.</p>
						<p>My load test says I can handle 20-30 concurrent users</p>
					</aside>
				</section>

			</div>
		</div>
		
		<svg height="0" width="00">
			<defs>
				<marker id="markerArrow" markerWidth="13" markerHeight="13" refX="2" refY="6" orient="auto">
					<path d="M2,2 L2,11 L10,6 L2,2" style="fill: red;" />
				</marker>
			</defs>
		</svg>

		<script src="js/reveal.js"></script>
		<script src="plugin/math/math.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				history: true,
				math: {
					mathjax: 'https://cdn.jsdelivr.net/gh/mathjax/mathjax@2.7.8/MathJax.js',
					config: 'TeX-AMS_HTML-full',
				},
				plugins: [ RevealMath ],
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});
		</script>
	</body>
</html>
