<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Docker composability and Gentoo instrumenting</title>

		<meta name="description" content="Docker's issues with composing a container and how Gentoo (or a good package manger in general) can help">
		<meta name="author" content="Stefan Langenmaier">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<div class="slides">
				<section>
					<h1>Docker</h1>
					<h2>and its (composability) issues</h2>
					<h3>and how a good package manager can solve them</h3>
					<p>
						<small>Created by <a href="https://github.com/stefan-langenmaier">Stefan Langenmaier</a></small>
					</p>
					
					<aside class="notes">
						Bienvenue a la présentation Docker, ses issues "composability" et comment un bon gestionnaire de paquets peut les résoudre.
						
						Je ne veux pas parler de tous les problèmes Docker, mais je vais donner de references. :)
						
						La présentation a deux parties. Dans la première je vais essayer de illustrer le problème. La deuxième va être une demonstration.
						
						Dans la deuxième on va avoir du pause ou on attends l'installation, ça serait un bonne idée de poser des questions pendant cette phase.
					</aside>
				</section>

				<section>
					<h2>What is docker?</h2>
					<p>
						Good question!
					</p>
					
					<aside class="notes">
						<ul>						
						    <li>c'est une compagnie</li>
						    <li>un outil pour (créer, rouler, deployer, supprimer) gérér les containers et  les images sur des différents platforms (linux, mac, win),</li>
						    <li>un hôte pour les images (on peut avoir un compte, penser à un appstore)</li>
						    <li>une libraire et interface dans l'infrastructue de conteneur du kernel</li>
						</ul>
						
						Docker est beaucoup de différents choses. C'est une de raison pourquoi un competiteur à créer son propre outil (rkt).
					</aside>
				</section>

				<section>
					<h2>Virtualisation vs Containerisation</h2>
					<p>
						What is the difference?
					</p>
					
					<aside class="notes">
						J'ai  déjà parlé de conteneurs, mais c'est quoi et pourquoi est-ce que c'est nouveau.
						<ul>						
						    <li>Full virtualised systems: chaque système roule sur son propre kernel. Sur hardware moderne il y a support d'execution. La reduction de performance est negligible.</li>
						    <li>Paravirtualised systems: chaque système roule sur son propre kernel. mais le kernel sais qu'il est virtualisé et il est optimisé pour ça.</li>
						
						    <li>Containerized systems: tous les systèmes roulent sur le même kernel. Ce kernel a le contrôle global de ressource. Probablement les systèmes competitive peuvent parler. Ça peut améliorer la performance. Le temps de démarrage est pratiquement instantané.</li>
						</ul>
						
						
						<p>C'est claire que la performance va être la meilleure avec les système containeriser. Génerelement une bonne idéeÉ Ça depends. :)
						Les conteneurs promessent "create once - deploy everywhere", mais si on exclude le kernel dans l'image le comportement peut changer dans le futur si on metrre-à-jour le kernel ou si on change la distribution. La promesse de comportment reproduisible est exageré. La vrai virtualisation peut être plus stable dans cette domaine.</p>
					</aside>
				</section>

				<section>
					<h2>Containerization differences/alternatives</h2>
					
					<ul>
						<li>uml</li>
						<li>OpenVZ</li>
						<li>Linux VServer</li>
					</ul>
					
					<ul>
						<li>docker</li>
						<li>lxd</li>
						<li>lxc</li>
						<li>lmctfy</li>
						<li>rocket</li>
						<li>systemd-nsspawn</li>
					</ul>
						
					<ul>
						<li>jails</li>
						<li>zones</li>
					</ul>
					
					<aside class="notes">
						C'est un peu l'histoire de conteneurs.  
						<ul>
						    <li>uml</li>
						    <li>OpenVZ</li>
						    <li>Linux VServer</li>
						    Ces solutions ont existé avant. Elles n'étaint pas inclus dans le kernel. Ou elles étaient propriétaires.
						    they are only available via patches not part of the official kernel
						</ul>
					    
					    	<ul>
						    <li>docker</li>
						    <li>lxd</li>
						    <li>lxc</li>
						    <li>lmctfy</li>
						    <li>rocket</li>
						    <li>systemd-nsspawn</li>
						</ul>
						Les façon actuelles, elles sont implémente avec cgroups dans le kernel. Donc le mis-à-jour vont être facile dans le futur.
						
						<ul>
						    <li>jails</li>
						    <li>zones</li>
						</ul>
						Les choses similaire pour les OS différents (BSD et Solaris)
						
					</aside>
				</section>

				<section>
					<h2>Known problems of Docker</h2>
					<p>
					    I don't want to go <a href="#/references">there</a>.
					</p>
					
					<aside class="notes">
						J'ai ajouté des liens à la fin pour les interessé
						
						Il y a des avis différents:
						
						les reseau n'est pas bien implémenté.
						Il n'y a pas d'infrastructure de sécurité. (signed images)
					</aside>
				</section>

				<section>
					<h2>The problem I want to talk about here</h2>
					
					<ul>
					    <li>Developing with a container</li>
					    <li>Creating a production system from a container</li>
					</ul>
					    
					<aside class="notes">
						Je veux parler de deux choses
						l'experimnetation avec un conteneur, ça veux dire le développement et les test. Ça inclue les changements sur plusieurs niveau.
						
						et la deuxième chose c'est la création d'un conteneur minimal pour la production
						
						Ce sont deux tâches différents, mais elles sont liées.
					</aside>
				</section>
				
				<section>
					<h2>Example Dockerfile</h2>
					<pre><code data-trim>
FROM phusion/baseimage:0.9.16
MAINTAINER Phusion &lt;info@phusion.nl&gt;

ENV HOME /root
ADD . /pd_build
RUN /pd_build/install.sh
CMD ["/sbin/my_init"]
EXPOSE 80 443
					</code></pre>
					
					<aside class="notes">
						Un Dockerfile c'est un fichier de configuration qui décris comme une image est batti.
						
						Suivant on a un exemple, qui vient de phusion qui produit l'appi passenger. C'est une application qui interface ruby et le webserver.
						
						À la première vue il semble très claire et comprehensible.
						
						Mais à la deuxième fois?
						
						phusion/baseimage est maintenant la distribution, mais ce n'est pas claire comment la distribution fonctionnne et plus important comment on peut garder la distribution -à-jour
						
						et pourquoi est le dossier root le home. il semble que la sécurité n'est pas important.
						
						après le script import un dossier au complèt (pas de commentaire, rien, aucune idée qu'est-ce que dans le dossier)
						et après un fichier de ce dossier est executé (il semble qu le script va installer qc)
						
						la CMD specifie la commande qui roule au début du serveur
						normalement avec Docker un système d'init n'est pas necessaire, mais les gens de phusion dit oui c'est necessaire mais ils utilisent un système fait à la main
						avec ça on est dans le pire du monde. on va laisser tomber l'infra/le support d'une "vrai" distro
						
						la dernière ligne est la seule raissonable. elle spécifie les port ouvert pour le webserver
					</aside>
				</section>
				
				<section>
					<h2>Example problem</h2>
					<table style="margin-left: -10%;">
						<thead>
							<tr>
								<td></td>
								<td>Webserver</td>
								<td>Interface</td>
								<td>Ruby</td>
								<td>DB</td>
								<td>Redmine</td>
								<td>Sum</td>							
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Combinations</td>
								<td>3</td>
								<td>2</td>
								<td>3</td>
								<td>2</td>
								<td>5</td>
								<td>180</td>
							</tr>
							<tr>
								<td style="white-space: nowrap;">Docker (*)</td>
								<td>3</td>
								<td>6</td>
								<td>18</td>
								<td>36</td>
								<td>180</td>
								<td>180+36=216</td>
							</tr>
							<tr>
								<td style="white-space: nowrap;">Composable (+)</td>
								<td>3</td>
								<td>5</td>
								<td>8</td>
								<td>10</td>
								<td>15</td>
								<td>180+15=195</td>
							</tr>
						</tbody>
					</table>
					<aside class="notes">
						Dans l'exemple suivant je veux utiliser ce cas. On vas installer l'application Redmine à partir de rien et on va être capable de choisir tous les composantes.
						Ici on peut voir un liste de haute niveau de composantes et on peut voir déjà un problème
						
						Le totale de combinaison est toujours le même, mais le totale d'éléments qui doivent être préparé monte plus rapide (exponentielle vers linear)
						
						On peut voir pour Docker ça serait 36 images à prepareé et pour les paquets classique ça serait 15 à preparé. Si on imagine qu'on veux ajouter un autre chouche avec seulement deux option, ça serait 72 images pour Docker et 17 pour les paquets.
						
						ça s'appelle curse of dimensions si qqn veux google cela.
						
						On ne va jamais essayer toutes les combinaison, mais peut-être on ne sait pas au début quelle combinaison est la bonne.
					</aside>
				</section>
				
				<section>
					<h2>Let's visualize it (stacked)</h2>
					<div id="stackednetwork" style="height: 50vh; width: 100%;"></div>
					
					<aside class="notes">
						Pour rendre cela plus compréhensible j'ai essayé de visualiser le comportement. Si on veux changer un paquet au niveau bas on doit modifier toutes les images dessus.
                    			</aside>
				</section>
				
				<section>
					<h2>Let's visualize it (composed)</h2>
					<div id="composednetwork" style="height: 50vh; width: 100%;"></div>
                    			
                    			<aside class="notes">
                    				Les paquets ici sont plus complexe, mais ils peuvent fonctionner avec plusieurs versions
                    			</aside>
				</section>
				
				

				<section>
					<h2>You can ignore this problem</h2>
					<ul>
						<li>if you like monocultures</li>
						<li>if you like vendor-lockin</li>
						
					</ul>
					<aside class="notes">
						on peut ignore ce problème
						si le travail pour experimenter est trop haut on a crée une sorte de vendor lock-in et on empecher des nouvelles approches.
					</aside>
				</section>

				<section>
					<h2>Solutions to this</h2>
					<p>good package managers</p>
					<ul>
						<li>stable</li>
						<li>support/upstream</li>
						<li>best-practices</li>
						<li>documentation</li>
					</ul>
					<aside class="notes">
						les gestionnaires de paquets déjà existe pour longtemps est ils sont très stable
						on a une communication qui est établi avec upstream (parce que docker est plus comme un silo)
						il y a une bonne documentation avec les meillure-pratique
						
						chaque fois on install une application sans gestionnaire de paquets, on dit qu'on connais l'application mieux qu tous les developpeurs de vos distro favori
					</aside>
				</section>
				
				<section>
					<h2>Example - Gentoo</h2>
					<p>
						Creating a minimal Redmine installation with lxc and portage as package manger for Gentoo.

					</p>
					<aside class="notes">
						Discloser: Si ce n'est pas connu, j'aime utiliser Gentoo
						
						On va utiliser Gentoo pour installer Redmine
						Gentoo va fournir portage, c'est le gestionnaire de paquets et l'installation lxc laquelle on utilise pour rouler les conteneur. Mais c'est aussi possible avec d'autres distro et gestionnaire de paquets.
						
						On va voir deux système. Une runtime qui contenir Redmine à la fin avec toutes les dépendendances nécessaire.
						Un sytème qui va bootstraper l'installation parce qu'on commence à zero.
					</aside>
				</section>
				
				<section>
					<h2>Base Installation</h2>
					<ol>
						<li>lxc-create -n redmine-runtime -t gentoo-runtime -- --template /home/stefan/git/lxc-gentoo-build-tools/redmine-runtime-template</li>
						
						<li>nano config</li>
						
						<li>emerge baselayout openrc shadow util-linux bash coreutils -av -j4</li>
						
						<li>emerge grep net-tools procps gcc findutils nano sed -av -j4</li>
						
					</ol>
					
					<aside class="notes">
						Le dossier de template contient seulement les fichiers de configuration. Aucune executable.
						
						Le gentoo-runtime a créé la configuration.
						
						La première commande install les outils nécessaire pour le système openrc, on pourrait choisir aussi systemd, la deuxième fais une installation à la base.
						
						Une système de base de Gentoo est prêt
					</aside>
				</section>
				
				<section>
					<h2>Redmine Installation</h2>
					<ol>
						<li>emerge redmine -av -j4</li>
					</ol>
					
					<aside class="notes">
						L'installation de Redmine est facile.
					</aside>
				</section>
				
				<section>
					<h2>Redmine Configuration</h2>

					<ol>
						<li>emerge --config "=www-apps/redmine-9999"</li>
						 
						
						<li>groupadd apache</li>
						<li>useradd -g apache apache</li>
						<li>chown apache:apache .</li>
						<li>chown apache:apache db/ files/ tmp/ -R</li>

						<li>/etc/init.d/apache2 start</li>

					</ol>
					
					<aside class="notes">
						Il faut qu'on fasse la configuration. Ça peut prendre un peu du temps. On n'a pas installé tous les dépendences avec Gentoo (c'est aussi possible), mais parce qu'on utilise le code qui vient directement du git, on utilse bundler pour fournir les dépendences de Ruby.
						
						Après il faut qu'on ajoute les permission et ça devrait être tous.
					</aside>
				</section>
				
				<section>
					<h2>Change of webserver</h2>

					<ol>
						<li>emerge nginx</li>
						<li>/etc/init.d/apache2 stop</li>
						<li>/etc/init.d/nginx start</li>
					</ol>
					
					<aside class="notes">
						Un exemple comment on peut changer les composantes. On va installer nginx comme serveur web.
					</aside>
				</section>
				
				<section>
					<h2>Import into Docker</h2>

					<ol>
						<li>sudo tar -c . | sudo docker import - reponame</li>
					</ol>
					
					<aside class="notes">
						If for the deployment in production the high-level tools of docker are better suited you can cimport the whole directory at anytime into Docker.
					</aside>
				</section>
				
				

<!--				
				<section>
					<h2>Installation cleanup</h2>
					<ol>
						<li>emerge gcc portage perl python -C -av</li>
					</ol>
				</section>
				
-->

				<section>
					<h2>Thanks - Q/A</h2>
				</section>

				<section id="references">
					<h1>Links/References</h1>
					<ul>
						<li><a href="http://www.boycottdocker.org/">boycott docker</a></li>
						<li><a href="http://thenewstack.io/coreos-calls-docker-fundamentally-flawed-releases-prototype-alternative/">coreos and rocket</a></li>
						<li><a href="http://en.wikipedia.org/wiki/Operating-system-level_virtualization">Wikipedia: Operating-system-level Virtualization</a></li>
						<li><a href="https://www.packer.io/docs/builders/docker.html">packer</a></li>
						<li><a href="http://www.vitavonni.de/blog/201503/2015031201-the-sad-state-of-sysadmin-in-the-age-of-containers.html">container rant</a></li>
						<li><a href="https://www.andreas-jung.com/contents/the-case-against-docker">another container rant</a></li>
						<li><a href="http://reventlov.com/advisories/using-the-docker-command-to-root-the-host">docker vurn</a></li>
						<li><a href="https://chimeracoder.github.io/docker-without-docker/#34">docker without docker</a></li>
						<li><a href="https://coreos.com/blog/rkt-0.5.4/">rkt authentication</a></li>
					</ul>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>
		<script src="js/vis.min.js"></script>
		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>
		
		<script type="text/javascript">
		    var levels = [3, 2, 3, 2, 5];
		    var nodeIdCounter = 0;
		    function generateGraph(levels, data, level, nodeId) {
		        var nodes = data['nodes'];
   		        var edges = data['edges'];
		        for (var i = 0; i < levels[level]; i++) {
                    nodes.push({
                        id: nodeIdCounter,
                        label: "*",
                        level: level+1
                    });
                    edges.push({
                        from: nodeId,
                        to: nodeIdCounter
                    });
                    nodeIdCounter++;
                    if (level<=levels.length) {
                        data = generateGraph(levels, data, level+1, nodeIdCounter-1);
                    }
                }
                
		        return data;
		    }
		    
            var nodes = [
                {id: nodeIdCounter++, label: 'LDB', level: 0}
            ];
            var edges = [];
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            data = generateGraph(levels, data, 0, nodeIdCounter-1);
            
            // create a network
            var container = document.getElementById('stackednetwork');
            
            var options = {
                stabilize: false,
                smoothCurves: false,
                hierarchicalLayout: {
                    direction: "UD"
                }
            };

            var network = new vis.Network(container, data, options);
        </script>
        
        <script type="text/javascript">
		    var levels = [3, 2, 3, 2, 5];
		    var nodeIdCounter = 0;
		    function generateGraph(levels, data, level, nodeId) {
		        var nodes = data['nodes'];
   		        var edges = data['edges'];
		        for (var i = 0; i < levels[level]; i++) {
                    nodes.push({
                        id: nodeIdCounter,
                        label: "*",
                        level: level+1
                    });
                    for (var k = 0; k < nodes.length; k++) {
                        var n = nodes[k];
                        if (n['level'] === level) {
                            edges.push({
                                from: n['id'],
                                to: nodeIdCounter
                            });
                        }
                    }
                    nodeIdCounter++;

                }
                if (level<=levels.length) {
                    data = generateGraph(levels, data, level+1, nodeIdCounter-1);
                }
                
		        return data;
		    }
		    
            var nodes = [
                {id: nodeIdCounter++, label: 'LDB', level: 0}
            ];
            var edges = [];
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            data = generateGraph(levels, data, 0, nodeIdCounter-1);
            
            // create a network
            var container = document.getElementById('composednetwork');
            
            var options = {
                stabilize: false,
                smoothCurves: false,
                hierarchicalLayout: {
                    direction: "UD"
                }
            };

            var network = new vis.Network(container, data, options);
        </script>

	</body>
</html>
