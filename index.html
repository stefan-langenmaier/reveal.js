<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Docker composability and Gentoo instrumenting</title>

		<meta name="description" content="Docker's issues with composing a container and how Gentoo (or a good package manger in general) can help">
		<meta name="author" content="Stefan Langenmaier">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<div class="slides">
				<section>
					<h1>Docker</h1>
					<h2>and its (composability) issues</h2>
					<h3>and how a good package manager can solve them</h3>
					<p>
						<small>Created by <a href="https://github.com/stefan-langenmaier">Stefan Langenmaier</a></small>
					</p>
					
					<aside class="notes">
						I want to talk about some specific problems that exists in my opinion specifically for the Docker system
						
						I won't talk about all the known problems, but I will give some sources :)
						
						You can pose questions at anytime, but we'll have some waiting time during the installation of packages, so it would be a good idea to pose the questions during that time.
					</aside>
				</section>

				<section>
					<h2>What is docker?</h2>
					<p>
						Good question!
					</p>
					
					<aside class="notes">
						<ul>						
						    <li>it's a company,</li>
						    <li>a tool to manage (create, run, deploy, delete) containers and images on different platforms (linux, mac, win),</li>
						    <li>a host for these images (where you can have an account, think app store)</li>
						    <li>a library to interface the linux kernel container infrastructure</li>
						</ul>
						
						it's a lot of different things (one of the reasons a "competitor" started it's own library rkt)
					</aside>
				</section>

				<section>
					<h2>Virtualisation vs Containerisation</h2>
					<p>
						What is the difference?
					</p>
					
					<aside class="notes">
						I talked about containers? What are these and why are they new?
						<ul>						
						    <li>Full virtualised systems all run on their on kernels. Modern hardware has support for it.</li>
						    <li>Paravirtualised systems run on their on kernel, but the kernel knows its running virtualised and is optimized for that.</li>
						
						    <li>Containerized systems run all on the same kernel. So this kernel has a global ressource control and can do a global optimzation of the resources.
						Possibly big performance gains now and in the future. Competing environments can "talk" to each other.</li>
						</ul>
						
						
						<p>So generally a good idea to use containers? Well it depends. :)
						They all promise "create once - deploy everywhere", but as you exclude your kernel from the image your behaviour can change in the future when you update your kernel or when you change your distribution. The promise of reproduceable behaviour is overrated. It would be easier/more reliable with vrtualisation.</p>
					</aside>
				</section>

				<section>
					<h2>Containerization differences/alternatives</h2>
					
					<ul>
						<li>uml</li>
						<li>OpenVZ</li>
						<li>Linux VServer</li>
					</ul>
					
					<ul>
						<li>docker</li>
						<li>lxd</li>
						<li>lxc</li>
						<li>lmctfy</li>
						<li>rocket</li>
						<li>systemd-nsspawn</li>
					</ul>
						
					<ul>
						<li>jails</li>
						<li>zones</li>
					</ul>
					
					<aside class="notes">
					    What are the differences?
						Why do they exist?
						<ul>
						    <li>uml</li>
						    <li>OpenVZ</li>
						    <li>Linux VServer</li>
						    they are only available via patches not part of the official kernel
						</ul>
					    
					    	<ul>
						    <li>docker</li>
						    <li>lxd</li>
						    <li>lxc</li>
						    <li>lmctfy</li>
						    <li>rocket</li>
						    <li>systemd-nsspawn</li>
						</ul>
						    they are all based on cgroups, which is in the vanilla kernel. so easy upgrades in the future very important point, as all your containers depend on that kernel
						
						<ul>
						    <li>jails</li>
						    <li>zones</li>
						</ul>
						    similar things for other OSes
						
					</aside>
				</section>

				<section>
					<h2>Known problems of Docker</h2>
					<p>
					    I don't want to go <a href="#/references">there</a>.
					</p>
					
					<aside class="notes">
						check out the links at the end
						
						different people say different things
						be it the network is not properly implemented
						be it the whole infrastructure is not secure (no signed images)
						
						you can have a look into the links at the end
					</aside>
				</section>

				<section>
					<h2>The problem I want to talk about here</h2>
					
					<ul>
					    <li>Developing with a container</li>
					    <li>Creating a production system from a container</li>
					</ul>
					    
					<aside class="notes">
						Experimenting with a container - development and especially testing
						=> Changing components on multiple levels
						
						and then create a minimal production container at the end
						
						These are two different tasks but they are normally related to each other
						
					</aside>
				</section>
				
				<section>
					<h2>Example Dockerfile</h2>
					<pre><code data-trim>
FROM phusion/baseimage:0.9.16
MAINTAINER Phusion &lt;info@phusion.nl&gt;

ENV HOME /root
ADD . /pd_build
RUN /pd_build/install.sh
CMD ["/sbin/my_init"]
EXPOSE 80 443
					</code></pre>
					
					<aside class="notes">
						A Dockerfile is script/configuration that describes how an image is built
						
						At first sight this looks very clear and understandable
						
						Phusion baseimage is now our distribution, unclear what distribution it is based on and if we can even do updated on it
						
						
						why is root the home directory, well security does not to be so important, better read the references at the end
						
						we import a whole directory of bash scripts
						
						and execute them, no idea what they are doing
						
						we run a custom init system, because docker systems don't need one, but this distributions says its better to uses one
						so we are in the worst of all worlds
						
						the only reasonable line, this will be a web server so we'll open the ports
					</aside>
				</section>
				
				<section>
					<h2>Example problem</h2>
					<table style="margin-left: -10%;">
						<thead>
							<tr>
								<td></td>
								<td>Webserver</td>
								<td>Interface</td>
								<td>Ruby</td>
								<td>DB</td>
								<td>Redmine</td>
								<td>Sum</td>							
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Combinations</td>
								<td>3</td>
								<td>2</td>
								<td>3</td>
								<td>2</td>
								<td>5</td>
								<td>180</td>
							</tr>
							<tr>
								<td style="white-space: nowrap;">Docker (*)</td>
								<td>3</td>
								<td>6</td>
								<td>18</td>
								<td>36</td>
								<td>180</td>
								<td>180+36=216</td>
							</tr>
							<tr>
								<td style="white-space: nowrap;">Composable (+)</td>
								<td>3</td>
								<td>5</td>
								<td>8</td>
								<td>10</td>
								<td>15</td>
								<td>180+15=195</td>
							</tr>
						</tbody>
					</table>
					<aside class="notes">
						Curse of dimensions
						
						the non-composable build system has about 10% more combinations
						
						this is NOT the problem, they will always be of the same magnitude
						
						the problem is between the 15 and the 36
						with 15 packages prepared you can create any combination you want
						with 36 base images prepared you can create any last image you want, you still have to create it manually and adapted to each though
						
						it is sad because the matrix will only be sparsely populated
						
						we will NEVER try all possible combinations only the ones that seem interesting and this is not always known in advance
						
						but if the work to change/experiment/try is to high we are in a kind of vendor lock-in, the base where you are starting from decides on your tools
					</aside>
				</section>
				
				<section>
					<h2>Let's visualize it (stacked)</h2>
					<div id="stackednetwork" style="height: 50vh; width: 100%;"></div>
					
					<p>
					Now imagine you want to change a lower level package/setting
					then you have to recreate all images, that are based on this one.
                    
				</section>
				
				<section>
					<h2>Let's visualize it (composed)</h2>
					<div id="composednetwork" style="height: 50vh; width: 100%;"></div>
                    
				</section>
				
				

				<section>
					<h2>You can ignore this problem</h2>
					<ul>
						<li>if you like monocultures</li>
						<li>if you like vendor-lockin</li>
						
					</ul>
					<aside class="notes">
						but if you like variety in your experimenting and really minimal systems in production you're screwed
					</aside>
				</section>

				<section>
					<h2>Solutions to this</h2>
					<p>good package managers</p>
					<ul>
						<li>stable</li>
						<li>support/upstream</li>
						<li>best-practices</li>
						<li>documentation</li>
					</ul>
					<aside class="notes">
						they are around for a while and already pretty stable
						
						if your package manager really cannot do it, there is still bash available
						this is basically what a Dockerfile is doing but without obstructing you
						
						but every time you are installing an application without a package manager it means you know more about that application than all the developers of your favorite distro (probably not true)
					</aside>
				</section>
				
				<section>
					<h2>Example - Gentoo</h2>
					<p>
						Creating a minimal Redmine installation with lxc and portage a package manger for Gentoo.

					</p>
					<aside class="notes">
						creating a minimal Redmine installation
						
						this uses just lxc
						two containers, both are running Gentoo but the host can be whatever distribution you like
						
						one container runs the package manager
						the second one is not even a real Gentoo as there is not even a package manager installed in the end
						
						both a running openrc as init system (this could be changed to systemd or even none)
						the passenger people recommend to run it with an init system, but they are using something strange called my_init
					</aside>
				</section>
				
				<section>
					<h2>Base Installation</h2>
					<ol>
						<li>lxc-create -n redmine-runtime -t gentoo-runtime -- --template /home/stefan/git/lxc-gentoo-build-tools/redmine-runtime-template</li>
						
						<li>nano config</li>
						
						<li>emerge baselayout -av</li>
						
						<li>emerge openrc shadow util-linux bash coreutils -av -j4</li>
						
						<li>emerge grep net-tools procps gcc findutils nano sed -av -j4</li>
						
					</ol>
				</section>
				
				<section>
					<h2>Redmine Installation</h2>
					<ol>
						<li>emerge redmine -av -j4</li>
					</ol>

				</section>
				
				<section>
					<h2>Redmine Configuration</h2>

					<ol>
						<li>emerge --config "=www-apps/redmine-9999"</li>
						 
						
						<li>groupadd apache</li>
						<li>useradd -g apache apache</li>
						<li>chown apache:apache .</li>
						<li>chown apache:apache db/ files/ tmp/ -R</li>

						<li>/etc/init.d/apache2 start</li>

					</ol>
				</section>
				
				<section>
					<h2>Change of webserver</h2>

					<ol>
						<li>emerge nginx</li>
						<li>/etc/init.d/apache2 stop</li>
						<li>/etc/init.d/nginx start</li>
					</ol>
				</section>
				
				<section>
					<h2>Import into Docker</h2>

					<ol>
						<li>sudo tar -c . | sudo docker import - reponame</li>
					</ol>
					
					<aside class="notes">
						If for the deployment in production the high-level tools of docker are better suited you can cimport the whole directory at anytime into Docker.
					</aside>
				</section>
				
				

<!--				
				<section>
					<h2>Installation cleanup</h2>
					<ol>
						<li>emerge gcc portage perl python -C -av</li>
					</ol>
				</section>
				
-->

				<section>
					<h2>Thanks - Q/A</h2>
				</section>

				<section id="references">
					<h1>Links/References</h1>
					<ul>
						<li><a href="http://www.boycottdocker.org/">boycott docker</a></li>
						<li><a href="http://thenewstack.io/coreos-calls-docker-fundamentally-flawed-releases-prototype-alternative/">coreos and rocket</a></li>
						<li><a href="http://en.wikipedia.org/wiki/Operating-system-level_virtualization">Wikipedia: Operating-system-level Virtualization</a></li>
						<li><a href="https://www.packer.io/docs/builders/docker.html">packer</a></li>
						<li><a href="http://www.vitavonni.de/blog/201503/2015031201-the-sad-state-of-sysadmin-in-the-age-of-containers.html">container rant</a></li>
						<li><a href="https://www.andreas-jung.com/contents/the-case-against-docker">another container rant</a></li>
						<li><a href="http://reventlov.com/advisories/using-the-docker-command-to-root-the-host">docker vurn</a></li>
						<li><a href="https://chimeracoder.github.io/docker-without-docker/#34">docker without docker</a></li>
						<li><a href="https://coreos.com/blog/rkt-0.5.4/">rkt authentication</a></li>
					</ul>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>
		<script src="js/vis.min.js"></script>
		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>
		
		<script type="text/javascript">
		    var levels = [3, 2, 3, 2, 5];
		    var nodeIdCounter = 0;
		    function generateGraph(levels, data, level, nodeId) {
		        var nodes = data['nodes'];
   		        var edges = data['edges'];
		        for (var i = 0; i < levels[level]; i++) {
                    nodes.push({
                        id: nodeIdCounter,
                        label: "*",
                        level: level+1
                    });
                    edges.push({
                        from: nodeId,
                        to: nodeIdCounter
                    });
                    nodeIdCounter++;
                    if (level<=levels.length) {
                        data = generateGraph(levels, data, level+1, nodeIdCounter-1);
                    }
                }
                
		        return data;
		    }
		    
            var nodes = [
                {id: nodeIdCounter++, label: 'LDB', level: 0}
            ];
            var edges = [];
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            data = generateGraph(levels, data, 0, nodeIdCounter-1);
            
            // create a network
            var container = document.getElementById('stackednetwork');
            
            var options = {
                stabilize: false,
                smoothCurves: false,
                hierarchicalLayout: {
                    direction: "UD"
                }
            };

            var network = new vis.Network(container, data, options);
        </script>
        
        <script type="text/javascript">
		    var levels = [3, 2, 3, 2, 5];
		    var nodeIdCounter = 0;
		    function generateGraph(levels, data, level, nodeId) {
		        var nodes = data['nodes'];
   		        var edges = data['edges'];
		        for (var i = 0; i < levels[level]; i++) {
                    nodes.push({
                        id: nodeIdCounter,
                        label: "*",
                        level: level+1
                    });
                    for (var k = 0; k < nodes.length; k++) {
                        var n = nodes[k];
                        if (n['level'] === level) {
                            edges.push({
                                from: n['id'],
                                to: nodeIdCounter
                            });
                        }
                    }
                    nodeIdCounter++;

                }
                if (level<=levels.length) {
                    data = generateGraph(levels, data, level+1, nodeIdCounter-1);
                }
                
		        return data;
		    }
		    
            var nodes = [
                {id: nodeIdCounter++, label: 'LDB', level: 0}
            ];
            var edges = [];
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            data = generateGraph(levels, data, 0, nodeIdCounter-1);
            
            // create a network
            var container = document.getElementById('composednetwork');
            
            var options = {
                stabilize: false,
                smoothCurves: false,
                hierarchicalLayout: {
                    direction: "UD"
                }
            };

            var network = new vis.Network(container, data, options);
        </script>

	</body>
</html>
