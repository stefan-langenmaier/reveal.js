<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Distances, ads and other esoteric stuff</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/custom.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Distances, ads and other esoteric stuff</h1>
					<aside class="notes">
						<p>Herzlich willkommen. Gleich vorweg, der Vortrag ist schamlose Werbung für eine App. Die App wurde unteranderem an der letzten Weihnachtsfeier gebrainstormt. Ich hoffe dieses Jahr können wir den Teil mit dem Geld besprechen. Mehr sei aber noch nicht verraten. Links gibt es am Ende. Zunächst soll es um die folgenden Dinge gehen: Distances, ads and other esoteric stuff.</p>
						<p>Inhalt des Vortrags ist theoretischer Natur, wird aber versucht mit praktischen Beispielen und Problem näher gebracht.</p>
						<p>Ich würde mich freuen wenn Kritik gleich live reingeworfen wird.</p>
					</aside>
				</section>
				
				<section>
					<h2>What is <em>distance</em>?</h2>

					<dl>
						<dt>
							<dfn>
								<a href="https://en.wikipedia.org/wiki/Distance">Distance</a>
							</dfn>
						</dt>
						<dd>
							...is a numerical <em>measurement</em> of how far apart objects or points are.
						</dd>
					</dl>

					<aside class="notes">
						General, we go into details with more concrete examples in a second. Measurement is important because then we can compare it. This means the measurement converts it into a number.
						We'll ignore the "far apart" stuff as this is more philosophical.
					</aside>
				</section>
				
				<section>
					<h2>Where is it used?</h2>

					<ul>
						<li>Math (Geometry, Algebra, Statistics)</li>
						<li>Physics</li>
						<li>Geography</li>
						<li>Language (Search, NLP, Similarity)</li>
						<li>Computer science (Error correction codes)</li>
						<li>Marketing (Ads)</li>
					</ul>

					<aside class="notes">
						<p>
						We'll look into concrete examples, just wanted to show the breadth of the distance term. Maths, physics and geography probably come naturally to mind.
						</p>
						<p>But also in language there are a lot of topics and games, like word ladder.</p>
						<p>Marketing is using distances cluster group of data points (humans) in certain categories and the sell stuff to them.</p>
					</aside>
				</section>
				
				<section>
					<section>
						<h2>Geometric-Distance</h2>
						<p>
							<img alt="Geometric distance" src="images/manhattan_distance.svg" />
						</p>
						
						<ul>
							<li>Manhattan distance</li>
							<li>Euclidean distance</li>
						</ul>
						
						<aside class="notes">
							These are probably the most common and known distance metrics. 
						</aside>
					</section>
					
					<section>
						<h3>Manhattan distance</h3>

						<img alt="Geometric distance" src="images/manhattan_distance.svg" />

						<p>number of blocks to walk</p>
						
						<div style="position:relative; width:640px; height:200px; margin:0 auto;">
							<div class="fragment fade-out" width="640" height="200" style="position:absolute;top:0;left:0;">
							\[\begin{aligned}
							d(p,q) = (|p_{x} - q_{x} |) + (|p_{y} - q_{y} |)
							\end{aligned} \]
							</div>
							<div class="fragment" width="640" height="200" style="position:absolute;top:0;left:0;">
							\[\begin{aligned}
							d(p,q) = \sum\limits_{i}{|p_{i} - q_{i} |}
							\end{aligned} \]
							</div>
						</div>
						
						<aside class="notes">
							with "i" we walk over the dimensions of the points, so this can be any dimension
						</aside>
					</section>
					
					<section>
						<h3>Euclidean distance</h3>

						<img alt="Geometric distance" src="images/manhattan_distance.svg" />

						<p>as the crow flies</p>
						
						<p>
						\[ \begin{aligned}
						d(p,q) = \sqrt{\sum\limits_{i}{(p_{i} - q_{i})^{2}}}
						\end{aligned} \]
						</p>

						<aside class="notes">
							maybe you remember your pythagoras from school
							so there is also no limit on two dimensions, this works in three and higher dimensions
						</aside>
					</section>
					
					<section>
						<h3>Norm</h3>

						<p>
						\[ \begin{aligned}
						d_{k} (p,q) = \sqrt[k]{\sum\limits_{i}{|p_{i} - q_{i}|^{k}}}
						\end{aligned} \]
						</p>
						
						<p>for all k>0</p>

						<aside class="notes">
							mathematically this is generalized under the term Norm
							we'll get back to this later

							so much for the theoretical basis

						</aside>
					</section>
				</section>
				
				<section>
					<section>
						<h2>Distance Office - Kö</h2>

						<img src="images/o-to-k.png">

						<aside class="notes">
							now let's talk a little bit about the app. the app is supposed to bring people together. I know, another dating app and that during a pandemic, best idea ever.
							for a functioning dating app all you is an available and interest other person. first we will have a look at the geoprahical availability. we need to find a nearby person. it does not matter if there is a person two far away.

							for this we need to calculate the distance to that other person.

							So let's look at a real world example. What's the distance between our office and the Kö? Well we just put it in the previous formula.
						</aside>
					</section>
					<section>
						<h2>
						Distance Office - Kö
						</h2>

						<p class="fragment fade-in">
							\[ d_{2}(48.34237/10.90563,48.36650/10.89440) \]
						</p>

						<p class="fragment fade-in">
							\[  \approx 0,02661 \]
						</p>

						<ul class="fragment fade-in">
							<li><a href="https://de.wikipedia.org/wiki/Geographische_Breite#/media/Datei:Latitude_lines.svg">Latitude</a>: 1 deg = 111 km</li>
							<li><a href="https://de.wikipedia.org/wiki/Geographische_L%C3%A4nge#/media/Datei:Longitude_blue.svg">Longitude</a>: 1 deg = 111 km at the equator</li>
						</ul>

						<p class="fragment fade-in">
							\[ 0,026615221 * 111km \approx 2954m \]
						</p>

						<p class="fragment fade-in">
							2808m => 6% error
						</p>

						<aside class="notes">
							The result by the formula is in degrees, we need to convert them to meters.
							The problem with the conversion is that it does not work along the longitudes.
						</aside>
					</section>
					<section>
						<h2>Distance Office - Göggingen</h2>

						<img src="images/o-to-g.png">

						<aside class="notes">
							Let's try another distance. This time from the office to Göggingen.
						</aside>
					</section>
					<section>
						<h2>Distance Office - Göggingen</h2>

						<p class="fragment fade-in">
							\[ d_{2}(48.34237/10.90563,48.33831/10.86774)\]
						</p>

						<p class="fragment fade-in">
							\[ \approx 0,03811 \]
						</p>

						<p class="fragment fade-in">
							\[ 0,03811 * 111km \approx 4230m \]
						</p>

						<p class="fragment fade-in">
							2837m => 49% error
						</p>

						<aside class="notes">
							We can see the distance is larger. The real distance is about the same. This is caused by the direction of the distance. In this direction the effect of the longitudes it larger.
							How can we do better?
						</aside>
					</section>
					<section>
						<h2>
						<a href="https://en.wikipedia.org/wiki/Great-circle_distance">Great-circle distance</a>
						</h2>
						
						<p>
						<img alt="Geometric distance" src="images/illustration_of_great-circle_distance.svg" />
						</p>
						
						<p class="fragment fade-in">
						\[\begin{aligned}
						d(\lambda_1, \phi_1,\lambda_2, \phi_2) = 
						\end{aligned} \]
						\[\begin{aligned}
						r * \arccos\bigl(\sin\phi_1\sin\phi_2 + \cos\phi_1\cos\phi_2\cos(\Delta\lambda)\bigr)
						\end{aligned} \]
						</p>
						
						<aside class="notes">
							<p>a more real "world" example</p>
							<p>it's possible to use euclidean distance, we are searching for the distance of points in two dimensions, BUT the surface is on a 3d sphere</p>
							
							<p>with the earth here we have a three dimensional sphere but we want to find the distance of two points on the two dimensional surface</p>
							<p>so viel sei schon mal verraten in der App geht es darum sich mit anderen Menschen zu treffen (im RealLife(TM)), daher ein kleiner Exkurs wie ich das implementiert habe</p>
						</aside>
					</section>
					
					<section>
						<h2>What I did</h2>
						
						<pre><code class="hljs" data-trim data-noescape>
CREATE FUNCTION get_distance_in_meters_between_geo_locations(
  geo1_latitude DOUBLE, geo1_longitude DOUBLE,
  geo2_latitude DOUBLE, geo2_longitude DOUBLE
) RETURNS decimal(20,10) DETERMINISTIC
BEGIN
  return 1000 * 6371 *
    acos(
        cos(radians(geo1_latitude)) *
        cos(radians(geo2_latitude)) *
        cos(radians(geo1_longitude) -
            radians(geo2_longitude)
        ) +
        sin(radians(geo1_latitude)) *
        sin(radians(geo2_latitude))));
						</code></pre>
						
						<aside class="notes">
							einfach mal in SQL bauen,
							wenn man die Koordinaten  in einer Datenbanktabelle hat kann man die Tabelle einfach auf sich selbst joinen und den Abstand für alle berechnen und dann sotieren
						</aside>
					</section>
					
					<section>
						<h2>What I should do</h2>
						
						<p>
							<blockquote>...the spherical law of cosines formula can have large rounding errors if the distance is small</blockquote>
							
							<img src="images/akward-monkey-looking.jpg" class="scaled-img"/>
						</p>
						
						<p>
							<a href="https://en.wikipedia.org/wiki/Haversine_formula">Haversine formula</a>
						</p>
						
						<aside class="notes">
							machmal sollte man aber nicht gleich den ersten Alogrithmus aus dem Internet kopieren,
							sondern bei Wikipedia noch kurz weiterlesen
							
							wäre eine triviale Verbesserung, aber...
						</aside>
					</section>
					
					<section>
						<h2>What I should do</h2>
						
						<p>
							<blockquote>...are based on the assumption that the figure of the Earth is an oblate spheroid</blockquote>
							
							<img src="images/akward-monkey-looking.jpg" class="scaled-img"/>
						</p>
						<p>
							<a href="https://en.wikipedia.org/wiki/Vincenty%27s_formulae">Vincenty's formula</a>
						</p>
						
						<aside class="notes">
							aber wenn man dann zu lange bei Wikipedia weiterliest findet man vielleicht auch zu viel.

							funktioniert auch für elipsoide, wie die Erde, aber schwierig in SQL zu implementieren (iterativ)

							und dann hat man schon keine Lust mehr das anzufassen, vor allem weil man dann anfängt nachzudenken und fest stellt
						</aside>
					</section>
					
					<section>
						<h2>What I should do</h2>
						
						<p>
							<a href="https://ericandrewlewis.github.io/how-a-quadtree-works/">Don't calculate it for all points!</a><br />
							<img src="images/quadtree.png" class="scaled-img"/>
						</p>
						
						<a href="https://en.wikipedia.org/wiki/Quadtree">Quadtrees</a>
						
						<aside class="notes">
							<p>Die App will die beiden nächsten Personen zusammenbringen, ich muss nicht den Abstand zu allen bestimmen</p>

							<p>Gibt es da eine bessere Möglichkeit?</p>

							<p>wenn wir schon bei Optimierung sind,
							Datenstruktur die effizient den nächsten Nachbar finden kann.
							there are techniques to map this to databases: https://en.wikipedia.org/wiki/Z-order_curve</p>
							<p>Wird in Spielen verwendet z.B. das Map-Format für Quake BSP (binary space partitioning) ist eine spezielle Form davon.
							Für 3D Engines ist es z.B. besser wenn es keine Quadrate sondern Dreiecke sind.</p>
						</aside>
					</section>
					
					<section>
						<h2>What I really should do</h2>
						
						<p>Not using <a href="https://jira.mariadb.org/browse/MDEV-13467">MariaDB</a></p>
						
						<p>I need more than the nearest point for other reasons </p>
						
						<pre><code class="hljs" data-trim data-noescape>
SELECT ST_AsText(geom), city
FROM person.address
ORDER BY geom &lt;-&gt; 'POINT(-121.626 47.8315)'
FETCH FIRST 7 ROWS ONLY;
						</code></pre>
						
						<a href="https://postgis.net/docs/geometry_distance_knn.html">PostGIS kNN</a>
						
						<aside class="notes">
							Use the proper tool, don't implement it
							postgis hat auch Funktionen zum Abstand auf einer Kugel oder einem Elipsoid zu bestimmen

							so now we come to another aspect of availability. you can swipe in your tinder catalogue all day, but if you never go out then though look
							what I want to say is that while you are browsing you could already be outside on you way, the next step is the navigation, so you can find this person.
						</aside>
					</section>
				</section>
				
				<section>
					<h2>Compass and web apps</h2>
					
					<section>
						<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Detecting_device_orientation">Device orientation</a></p>
						
						<pre><code class="hljs" data-trim data-noescape>
						window.addEventListener("deviceorientation",
							handleOrientation);
						
						function handleOrientation(event) {
							var absolute = event.absolute;
							var alpha    = event.alpha;
							var beta     = event.beta;
							var gamma    = event.gamma;
						}
						</code></pre>
						
						<aside class="notes">
							<p>now that we know where a person is we need to find out how to get three</p>

							<p>the mobile phone should guide us in the "shortest way", in this case as the crow flies</p>

							<p>no routing but just the direction, for this we need the orientation of the phone</p>
						</aside>
					</section>
					
					<section>
						<dl>
							<dt><a href="https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/absolute">absolute=northbound</a></dt>  
							<dd>On return, absolute is true if the orientation data in instanceOfDeviceOrientationEvent is provided as the difference between the Earth's coordinate frame and the device's coordinate frame, or false if the orientation data is being provided in reference to some arbitrary, device-determined coordinate frame.</dd>
						</dl>
						
						<aside class="notes">
							northbound is nowadays, a missing feature, it was removed for multiple reasons
							better VR/AR and web compatability with safari
						</aside>
					</section>
					
					<section>
						<p>Spoiler and confusion</p>
						
						<ul>
							<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/ondeviceorientationabsolute">MDN</a></li>
							<li><a href="https://w3c.github.io/deviceorientation/spec-source-orientation.html#deviceorientationabsolute">W3C</a></li>
						</ul>
						
						<aside class="notes">
							<p>solution consensus from the Chrome dev was to create a new event, but according to MDN it's not supported and non standard</p>
							
							<p>according to W3C it is, maybe somebody can explain this to me later</p>

							<p>so I could use this functionality and give up on Firefox, that huge market share on mobile devices OR ....</p>
						</aside>
					</section>
					
					<section>
						
						<img src="images/new-project.jpg" />
						<p>Idea: <em>just</em> calculate it yourself!</p>
						
						<aside class="notes">
							<p>no to be honest, I was not aware of this functionality or at least it did not work for me turns out the compass on the mobile devices does not work well if the devices lies motionless on a table</p>
							<p>the idea is, if I have the current gps locations and the current relative position i can infer the absolute orientation with multiple data points</p>
							<p>in the following I'll describe the high level approach and the building blocks</p>
						</aside>
					</section>
				</section>
				
				<section>
					<h2>Hobocompass</h2>
					
					<svg height="500" width="500">
						<line x1="250" y1="500" x2="250" y2="20" class="arrow base" />
						
						<g class="fragment">
							<line x1="245" y1="500" x2="245" y2="300" class="arrow odd" />
							<line x1="255" y1="400" x2="255" y2="200" class="arrow even" />
							<line x1="245" y1="300" x2="245" y2="100" class="arrow odd" />
							<line x1="255" y1="200" x2="255" y2="020" class="arrow even" />
						</g>
						<g class="fragment fade-in-then-out">
							<text x ="250" y ="480" style="transform: rotate(45deg);" class="phone">📱</text>
							<text x ="250" y ="350" style="transform: rotate(30deg);" class="phone">📱</text>
						</g>
						<g class="fragment fade-in">
							<text x ="250" y ="400" style="transform: rotate(38deg);" class="phone">📱</text>
						</g>
						<g class="fragment fade-in-then-out">
							<text x ="250" y ="380" style="transform: rotate(45deg);" class="phone">📱</text>
							<text x ="250" y ="250" style="transform: rotate(30deg);" class="phone">📱</text>
						</g>
						<g class="fragment fade-in">
							<text x ="250" y ="300" style="transform: rotate(38deg);" class="phone">📱</text>
						</g>
						<g class="fragment fade-in-then-out">
							<text x ="250" y ="280" style="transform: rotate(45deg);" class="phone">📱</text>
							<text x ="250" y ="150" style="transform: rotate(30deg);" class="phone">📱</text>
						</g>
						<g class="fragment fade-in">
							<text x ="250" y ="200" style="transform: rotate(38deg);" class="phone">📱</text>
						</g>
						<g class="fragment fade-in-then-out">
							<text x ="250" y ="180" style="transform: rotate(45deg);" class="phone">📱</text>
							<text x ="250" y ="050" style="transform: rotate(30deg);" class="phone">📱</text>
						</g>
						<g class="fragment fade-in">
							<text x ="250" y ="100" style="transform: rotate(38deg);" class="phone">📱</text>
						</g>
					</svg>
					
					<aside class="notes">
						<p></p>let's assume the simple case where we walk straight norht and measure some distance walking with its geographic information and phone orientation</p>
						
						<p></p>split the distance into overlapping chunks</p>
						
						<p></p>average the orientation of the phone over a chunk, now you have and estimation where north is relative the phone orientation</p>
						
						<p></p>to make sure the orientation of the phone is sane we compare it with the next chunk</p>
						
						<p></p>you take this difference score over multiple chunks and you deem it safe enough</p>
						
						<p>how did I come up with this
						just looked what worked, sampling and sliding window</p>
						
						pros:
						<ul>
							<li>it evolved like this</li>
							<li>but sliding window is good not all data is important, just the most recent, dont carry arround wrong old data, ignore extreme points</li>
						</ul>
						
						cons: 
						<ul>
							<li>slow to start</li>
							<li>could be faster</li>
							<li>can run into wrong optimum and not recover from it</li>
							<li>no theoretical explanation</li>
						</ul>
					</aside>
				</section>
				
				<section>
					<h2>Angle/arc average</h2>
					
					<svg height="500" width="500">
						<circle cx="250" cy="250" r="2" class="point"/>
						
						<path class="arc odd" d="M 380,100 A 200,200 0 0 1 450,250" />
						
						<g class="fragment fade-in-then-out" data-fragment-index="0">
							<circle cx="347" cy="77" r="2" class="point"/>
						</g>
						<g class="fragment fade-in-then-out" data-fragment-index="0">
							<path class="arc even" d="M 315,60 A 200,200 0 0 1 450,250" />
						</g>
						
						<g class="fragment fade-in-then-out" data-fragment-index="1">
							<path class="arc even" d="M 50,250 A 200,200 0 0 1 450,250" />
							<path class="arc even" d="M 120,400 A 200,200 0 0 1  50,250" />
						</g>
						
						<g class="fragment fade-in-then-out" data-fragment-index="2">
							<path class="arc even" d="M 50,250 A 200,200 0 0 1 450,250" />
							<path class="arc even" d="M 120,400 A 200,200 0 0 1  50,250" />
						</g>
						
						<g class="fragment fade-in-then-out" data-fragment-index="2">
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(40deg);" class="arrow rotation" />
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(220deg);" class="arrow rotation" />
						</g>
						
						<g class="fragment" data-fragment-index="3">
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(40deg);" class="arrow rotation" />
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(20deg);" class="arrow rotation" />
						</g>
						
						<g class="fragment" data-fragment-index="4">
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(30deg);" class="arrow rotation average" />
						</g>
						
						<g class="fragment" data-fragment-index="5">
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(60deg);" class="arrow rotation" />
						</g>
					</svg>
					
					<aside class="notes">
						For the orientation of the phone per chunk we need to average this.
						
						How to average angles? Imagine we have two different angle we can represent it as two arc, so a sane person would say the average is somewhere in between
						
						What happens if the angle get wider, like for example the extreme on the other side? We could argue that it's perpendicular to the other two but we'll see in a second that doesn't make sense.
						
						How do we efficiently compute this with multiple angles.
						
						The trick is simple, we change the coordinate system and transform the angles to vectors.
					</aside>
				</section>
				
				<section>
					<h2>Angle/arc average</h2>
					
					<svg height="500" width="500">
						<circle cx="250" cy="250" r="200"/>
						
						<g class="fragment fade-in-then-out">
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(20deg);" class="arrow rotation" />
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(40deg);" class="arrow rotation" />
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(60deg);" class="arrow rotation" />
						</g>
						
						<g class="fragment fade-in-then-out">
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(20deg) scale(0.3);" class="arrow rotation" />
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(40deg) scale(0.3);" class="arrow rotation" />
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(60deg) scale(0.3);" class="arrow rotation" />
						</g>
						
						<g class="fragment fade-in">
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(20deg) scale(0.3);" class="arrow rotation" />
							<line x1="250" y1="250" x2="250" y2="50" style="transform: translate(20px, -55px) rotate(40deg) scale(0.3);" class="arrow rotation" />
							<line x1="250" y1="250" x2="250" y2="50" style="transform: translate(60px, -102px) rotate(60deg) scale(0.3);" class="arrow rotation" />
						</g>
						
						<g class="fragment fade-in">
							<line x1="250" y1="250" x2="355" y2="128" class="arrow rotation" />
						</g>
					</svg>
					
					<p><a href="https://en.wikipedia.org/wiki/Norm_(mathematics)">Euclidean norm</a></p>
					<p><a href="https://en.wikipedia.org/wiki/Cosine_similarity">Cosine similarity</a></p>
					
					<aside class="notes">
						This solves the issue how to add multiple angles. We just stack the tips on top of each other.
						
						And we get a sane solution for opposite angles as this cancels out the length of the vector and it doesn't make sense to talk about the orientation of a vector of length zero.
					</aside>
				</section>
				
				<section>
					<h2>Error distance</h2>
					
					<svg height="300" width="500">
						<circle cx="250" cy="250" r="200"/>
						
						<g class=" ">
							<line x1="250" y1="250" x2="250" y2="50" style="transform: rotate(20deg) scale(0.3);" class="arrow rotation" />
							<line x1="250" y1="250" x2="250" y2="50" style="transform: translate(20px, -55px) rotate(40deg) scale(0.3);" class="arrow rotation" />
							<line x1="250" y1="250" x2="250" y2="50" style="transform: translate(60px, -102px) rotate(60deg) scale(0.3);" class="arrow rotation" />
						</g>
						
						<g class=" ">
							<line x1="250" y1="250" x2="355" y2="128" class="arrow rotation" />
						</g>
					</svg>
					
					<p>
						\[\begin{aligned}
						\|\mathbf x + \mathbf y\| \leq \|\mathbf x\| + \|\mathbf y\|
						\end{aligned} \]
					</p>
					<p>
						<a href="https://en.wikipedia.org/wiki/Triangle_inequality">Triangle inequality</a>
					</p>
					
					<aside class="notes">
						This length actually gives us more information. Maybe you remember the triangle inequality from school or university.
						
						The sum of the two shorter sides of a triangle is always longer than the longer side.
						
						If we scale our unit vectors two the number of vectors we know for sure that the sum of their length can never be greater then one. This give a quality metric how much the phone was fiddled around in the hand.
						
						If all vector stack on top if each other the result vector is longer. If the phone is twisted and turned a lot the length is shorter. With this information we can make a decision which measurements we should ignore because our assumption of a steady walk does not hold.
					</aside>
				</section>
				
				<section>
					<h2>How should it be done?</h2>
					
					<p class="fragment" data-fragment-index="0">I have no idea. <span class="fragment" data-fragment-index="1">Well some.</span></p>
					
					<ol>
						<li class="fragment" data-fragment-index="1">Linear regression</li>
						<li class="fragment" data-fragment-index="3">ML/AI</li>
					</ol>
					
					<div style="position:relative; width:640px; height:380px; margin:0 auto;">
						<div class="fragment fade-in-then-out" data-fragment-index="0" width="640" height="380" style="position:absolute;top:0;left:0;">
							<img src="images/expanding-brain-1.jpg" />
						</div>
						<div class="fragment fade-in-then-out" data-fragment-index="1" width="640" height="380" style="position:absolute;top:0;left:0;">
							<img src="images/expanding-brain-2.jpg" />
						</div>
						<div class="fragment fade-in-then-out" data-fragment-index="2" width="640" height="380" style="position:absolute;top:0;left:0;">
							<img src="images/linear-regression.svg" />
						</div> 
						<div class="fragment fade-in-then-out" data-fragment-index="3" width="640" height="380" style="position:absolute;top:0;left:0;">
							<img src="images/expanding-brain-3.jpg" />
						</div>
					</div>
					
					<aside class="notes">
						Normally there are some typical approaches from here. We have the assumption that the orientation is related to the walking. So maybe we can use a linear regression.
						pros:
						* could be really fast
						* have a sound basis of the quality of the estimation
						
						But a linear regression is normally for an ordered input. But this is circular.
						
						We have issues when we get to the borders where the data loops, where close value looks like an outlier.
						
						So the simple coordinate transformation does not help here. I'm glad if somebody could this explain further to me.
						
						But as we are talking about linear regression we are already in the realm of ML and AI. Maybe someone has an idea to analyse the hand motion and can extract more data from this.
						
						Anyway there would be more data like gravity sensor and acceleration sensors that could be exploited. I just don't know how to include the data in a model for the prediciton.

						No that we know how to meet up the other person we need can go on to optimize the selection of the other person by their interest, for this there is a status feature. This is the sole way of interacting. You can only write emojis.
					</aside>
				</section>

				<section>
					<h2>Status feature</h2>
					
					<p>
						<ul>
							<li class="fragment">🏐🏆🥇</li>
							<li class="fragment">🎼🎤🎭</li>
							<li class="fragment">🗣️🇫🇷🇩🇪</li>
							<li class="fragment">🍆💦🍑</li>
						</ul>
					</p>
					
					<hr />
					
					<p>
						<ul>
							<li class="fragment">🎤🇫🇷🥇</li>
							<li class="fragment">🎤🎤🎤🇫🇷🥇</li>
						</ul>
					</p>

					<aside class="notes">
						If people are too far away you can't meet them, but maybe you want to have a hint for what they are looking for.
						
						So the app also has a status feature. The status is your status and at the same time what you are looking for.
						Only emojis are valid as input. We can talk about this later. So how could this look like.
						
						This could be sports. Looks like this is quite competitive.
						A jam session.
						A language exchange
						or helping someone to get his or her fruits and vegies sorted out.
						
						But we don't want to have a catalog to browse through it should match us with the best candidate.
					</aside>
				</section>
				
				<section>
					<h3>Euclidean distance (k=2)</h3>

					<p>
					\[\begin{aligned}
					d_{2} ((🎤🎤🥇),(🏐🏆🥇)) =
					\end{aligned} \]
					</p>
					
					<p>
					\[\begin{aligned}
					= {\sqrt{(🎤-🏐)^{2}}}  + {\sqrt{(🎤-🏆)^{2}}}  + {\sqrt{(🥇-🥇)^{2}}}
					\end{aligned} \]
					</p>

					<aside class="notes">
						We have already seen this approach it should also work here.
						
						We could use the unicode code points fill up missing dimensions if necessary and calculate it
						
						But...
					</aside>
				</section>
				
				<section>
					<h3>Literature</h3>

					<ul>
						<li><a href="https://homes.cs.washington.edu/~pedrod/papers/cacm12.pdf">A Few Useful Things to Know About Machine Learning</a></li>
						<li><a href="https://bib.dbvis.de/uploadedFiles/155.pdf">On the Surprising Behavior of Distance Metrics in High Dimensional Space</a></li>
					</ul>

					<aside class="notes">
						These metrics lose their meaning in higher dimensions with sparse filing.
						Almost all points are equally far apart.
						
						We get better results with L1 norm and even better ones with L&lt;1 "norms"
					</aside>
				</section>

				<section>
					<h2>What is similarity?</h2>
					
						<p><a href="https://en.wikipedia.org/wiki/Similarity_measure">Wikipedia</a></p>

					<aside class="notes">
						<p>Inverse of the distance on an interval from 0-1, 0 no similarity, 1 total similarity, triangle inequality does no longer hold.</p>
					</aside>
				</section>

				<section>
					<section>
						<h2>Textual-Distance</h2>
	
						<ul>
							<li><a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming distance</a></li>
							<li><a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a></li>
							<li><a href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf">tf–idf</a> / <a href="https://en.wikipedia.org/wiki/Okapi_BM25">BM25</a></li>
							<li><a href="https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance">Jaro-Winkler distance</a></li>
						</ul>
	
						<aside class="notes">
							So called <a href="https://en.wikipedia.org/wiki/String_metric">string metrics</a>
	
							<ul>
								<li>Hamming distance, simple for error correcting codes</li>
								<li>Levenshtein distance, uni homework because of dynamic programming</li>
								<li>tf–idf / BM25, are used in elasticsearch, better suited for longer texts good with context</li>
								<li>Jaro-Winkler, simple, works with strings, has a little bit of context</li>
							</ul>
	
							But if you can only meet people in your close vicinity this could get boring. So there should be some way to express yourself.
						</aside>
					</section>
					
					<section>
						<h2>Levenshtein distance</h2>
	
						<ol>
							<li><span class="fragment highlight-red" data-fragment-index="1">k</span>itten → <span class="fragment highlight-red" data-fragment-index="1">s</span>itten</li>
							<li>sitt<span class="fragment highlight-red" data-fragment-index="2">e</span>n → sitt<span class="fragment highlight-red" data-fragment-index="2">i</span>n</li>
							<li>sittin → sittin<span class="fragment highlight-red" data-fragment-index="3">g</span></li>
						</ol>
	
						<aside class="notes">
							So called <a href="https://en.wikipedia.org/wiki/String_metric">string metrics</a>
	
							<ul>
								<li>Hamming distance, simple for error correcting codes</li>
								<li>Levenshtein distance, uni homework because of dynamic programming</li>
								<li>tf–idf / BM25, are used in elasticsearch, better suited for longer texts good with context</li>
								<li>Jaro-Winkler, simple, works with strings, has a little bit of context</li>
							</ul>
	
							But if you can only meet people in your close vicinity this could get boring. So there should be some way to express yourself.
						</aside>
					</section>
					
					<section>
						<h2>Jaro-Winkler similarity</h2>

						<p>
						\[
						\begin{aligned} Sim_J (s_1, s_2) = \begin{cases} 0 &\text{if } m = 0, \\ \frac{1}{3}\left( \frac{m}{|s_1|} + \frac{m}{|s_2|} + \frac{m - t}{m} \right) &\text{otherwise}. \end{cases} \end{aligned}
						\]
						</p>

						<p>
						\[
						\left\lfloor \dfrac{\max (|s_1|, |s_2|)}{2} \right\rfloor - 1
						\]
						</p>
	
						<aside class="notes">
							The similarity is split into three parts.
							
							# How many matches relative to the first text length
							# How many matches realitve to the second text length
							# How many matches properly positioned

							Matches sind dabei Zeichen die in einem bestimmten Abstand übereinstimmen. Der bestimmte Abstand ist durch die untere Formel angegeben. Es ist ungefähr die Hälfte des kürzeren Strings.
						</aside>
					</section>
					<section>
						<h2>Jaro-Winkler similarity</h2>
						
						<p>s1=martha, s2=marhta</p>

						<p>
						\[
						\frac{1}{3}\left( \frac{m}{|s_1|} + \frac{m}{|s_2|} + \frac{m - t}{m} \right)
						\]
						</p>

						<p>
						\[
						\frac{1}{3}\left( \frac{6}{|6|} + \frac{6}{|6|} + \frac{6 - 1}{6} \right) = 0,944
						\]
						</p>

						<aside class="notes">
							Both string almost match completely except for a single transposition.
						</aside>
					</section>
					<section>
						<h2>Jaro-Winkler similarity</h2>
						
						<p>s1=martha, s2=arhtam</p>

						<p>
						\[
						\frac{1}{3}\left( \frac{m}{|s_1|} + \frac{m}{|s_2|} + \frac{m - t}{m} \right)
						\]
						</p>

						<p>
						\[
						\frac{1}{3}\left( \frac{5}{|6|} + \frac{5}{|6|} + \frac{5 - 1}{6} \right) = 0,822
						\]
						</p>

						<aside class="notes">
							The last m is no longer in the matching field and ignored.
						</aside>
					</section>
				</section>

				<section>
					<h2>What should I do</h2>
					
					<p><a href="https://en.wikipedia.org/wiki/Semantic_similarity">Semantic similarity</a> / 🏐 ≈ 🏀</p>
					
					<blockquote>"All emojis are equal, but some emojis are more equal than others."</blockquote>
					
					<aside class="notes">
						in general the approach is okay, not too many symbols or characters to compare, so a lot of the more complex algorithms don't fit here
						
						because of that reason one could use the information that some emojis are used in the same context
						
						resume, all ingredients together for a dating app.
						It can find the nearest person. Not very effiently but it works.
						It can give you the direction. "Working" on all devices. iPhones not really tested.
						And gives you a "best" match considering the distance to the person.
					</aside>
				</section>

				<section>
					<h2>Resume</h2>

					<ul>
						<li>Geo support</li>
						<li>Custom function support</li>
						<li>Near real time support</li>
					</ul>

					<p>How can I bring my queries in a simple way close to the database?</p>

					<aside class="notes">
						As I have geographic queries and similarity queries I'm not aware of a system that can do both.
						Especially that I want to fine tune the similarity algorithm and would like to avoid writing it all in SQL.

						The application is running on a RaspberyPi like device connect with a USB disk. If a client connects it creates about one query per seconds.
						With twenty clients this is the limits of how many queries this disk can handle. I don't need to have every query committed, a small delay is okay. I don't really need transaction isolation here. Something like near-realtime from Elasticsearch is good enough.

						Is there a backend where I can have the cake and eat it too?
					</aside>
				</section>

				<section>
					<h2>Thanks</h2>
					
					<p><a href="https://ärro.de">ärro.de</a></p>
					<p><a href="https://play.google.com/store/apps/details?id=de.xn__rro_pla.twa">Play Store</a></p>

					
					
					<aside class="notes">
						<p>For anyone who wants to test the app you can now test it here. Feedback is welcome. If you're inside be aware that it's not really working. The cool compass stuff is only active with firefox, but for this you need a good GPS signal. And make sure to have "device only" for your GPS activated otherwise Google holds back with updates of your location.</p>
						<p>My load test says I can handle 20-30 concurrent users</p>
					</aside>
				</section>

			</div>
		</div>
		
		<svg height="0" width="0">
			<defs>
				<marker id="markerArrow" markerWidth="13" markerHeight="13" refX="2" refY="6" orient="auto">
					<path d="M2,2 L2,11 L10,6 L2,2" style="fill: red;" />
				</marker>
			</defs>
		</svg>

		<script src="js/reveal.js"></script>
		<script src="plugin/math/math.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				viewDistance: 30,
				history: true,
				math: {
					mathjax: 'js/MathJax.js',
					config: 'TeX-AMS_CHTML-full',
				},
				plugins: [ RevealMath ],
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});
		</script>
	</body>
</html>
